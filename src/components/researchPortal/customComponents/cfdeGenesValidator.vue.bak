<template>
	<div>
		<!-- URL Parameter Choice Dialog -->
		<div v-if="showUrlChoiceDialog" class="url-choice-dialog-overlay">
			<div class="url-choice-dialog">
				<div class="url-choice-header">
					<h3>Choose Gene Source</h3>
					<p>Both associations and genes parameters were found in the URL. Please choose which gene source you'd like to use for validation:</p>
				</div>
				
				<div class="url-choice-options">
					<div class="url-choice-option">
						<div class="url-choice-title">
							<h4>Genes from Associations</h4>
							<p>Fetch genes from phenotype-gene set associations</p>
						</div>
						<div class="url-choice-preview">
							<strong>Associations data:</strong>
							<pre>{{ urlChoiceOptions.associations }}</pre>
						</div>
						<button @click="chooseAssociations" class="btn btn-primary url-choice-btn">
							Use Associations
						</button>
					</div>
					
					<div class="url-choice-option">
						<div class="url-choice-title">
							<h4>Genes from URL Parameter</h4>
							<p>Use the specific genes provided in the URL</p>
						</div>
						<div class="url-choice-preview">
							<strong>Genes:</strong>
							<span class="genes-list">{{ urlChoiceOptions.genes.join(', ') }}</span>
						</div>
						<button @click="chooseGenes" class="btn btn-primary url-choice-btn">
							Use Genes
						</button>
					</div>
				</div>
				
				<div class="url-choice-actions">
					<button @click="cancelUrlChoice" class="btn btn-outline-secondary">
						Cancel
					</button>
				</div>
			</div>
		</div>
		
        <!-- Two Column Layout for Upper Half -->
        <div class="upper-layout">
            <!-- Left Column (70%) - Hypothesis Section -->
            <div>
                <!-- Hypothesis to Validate Section -->
                <div id="hypothesis-section" class="hypothesis-container section-wrapper">
            
                    <div class="section-header">
                            <h4>Hypothesis to Validate</h4>
                    </div>
                    <div class="hypothesis-content">
                        <h5>Your Hypothesis (Use the <a href="/r/cfde_reveal" target="_blank">CFDE-REVEAL</a> to generate your hypothesis.)</h5>
                        <div class="textarea-container">
			<textarea 
                                v-model="phenotypeSearch" 
                                placeholder="Enter your hypothesis..."
				class="hypothesis-textarea"
				rows="3"
			></textarea>
                    </div>
                    <div class="gene-sets-input">
                        <div v-if="!hideAssociationsInput">
                            <label for="gene-sets">Load Genes from Phenotype Gene set Associations <a href="#" @click.prevent="toggleManualGeneInput" class="manual-add-link">(manually add genes)</a></label>
                            <small class="format-suggestion">Format data with comma-separated columns: Phenotype, Gene set, Source</small>
                            <textarea 
                                id="gene-sets"
                                v-model="geneSets" 
                                placeholder="e.g., rare inborn errors of metabolism, T69-Brown-Adipose_Male_8W_Down, motrpac"
                                class="gene-sets-field"
                                rows="3"
                            ></textarea>
                        </div>
                        <div v-if="!hideAssociationsInput && !showManualGeneInput && geneSets.trim() && (geneData.length === 0 || associationsModified)" class="load-genes-section">
                            <button 
                                @click="loadGenesFromAssociations" 
                                class="btn btn-secondary load-genes-btn"
                                :disabled="isLoadingGenes"
                            >
                                <span v-if="isLoadingGenes" class="loading-spinner-small"></span>
                                {{ isLoadingGenes ? 'Loading genes...' : 'Load genes' }}
                            </button>
                            <small class="load-genes-hint">Click to fetch genes from the phenotype-gene set associations above</small>
		</div>

		<!-- Gene Input Section (Primary) -->
                        <div class="gene-input-section">
                            <div class="gene-input-header">
                                <label for="manual-genes">Gene Symbols <a v-if="!hideAssociationsInput" href="#" @click.prevent="switchToAssociationsInput" class="switch-to-associations-link">
                                    (Load from Phenotype Gene set Associations)
                                </a></label>
                            </div>
			<small class="format-suggestion">Enter gene symbols separated by commas (e.g., GENE1, GENE2, GENE3)</small>
			<textarea 
				id="manual-genes"
				v-model="manualGenes" 
				placeholder="e.g., TP53, BRCA1, MYC, EGFR"
				class="manual-genes-field"
				rows="2"
			></textarea>
			<!-- Gene actions will be moved to user options -->
			</div>
		</div>

		<!-- Gene Exploration Options -->
		<div class="gene-options-section">
			<div class="gene-options-header">
				<h4>Explore Your Genes</h4>
				<p class="gene-options-description">Choose how you'd like to analyze the genes in your list. Enter genes above to enable the options below{{ hasHypothesis ? '' : ' (hypothesis scoring not available without hypothesis parameter)' }}:</p>
			</div>
			
			<div class="gene-options-grid">
				<!-- Option 1: Hypothesis Alignment and Research Gap Score -->
				<div v-if="hasHypothesis" class="gene-option-card">
					<div class="option-header">
						<h5>ðŸ§¬ Hypothesis Alignment & Research Gap Score</h5>
						<span class="option-badge">AI Analysis</span>
					</div>
					<div class="option-description">
						<p>Generate AI-powered scores showing how relevant and novel each gene is to your specific hypothesis. This will help prioritize which genes are most important for your research.</p>
					</div>
					<div class="option-details">
						<ul>
							<li>Hypothesis Alignment Score (1-10)</li>
							<li>Research Gap Score (1-10)</li>
							<li>Molecular rationale for each gene</li>
							<li>AI-generated context and justification</li>
						</ul>
					</div>
					<div class="option-actions">
				<button 
							@click="generateHypothesisAlignment"
							class="btn btn-primary option-btn"
							:disabled="!manualGenes.trim() || isGeneratingScores"
						>
							<span v-if="isGeneratingScores" class="loading-spinner-small"></span>
							Generate Scores
				</button>
						<span class="option-note">Requires hypothesis input</span>
					</div>
				</div>

				<!-- Option 2: GTEx Expression Analysis -->
				<div class="gene-option-card">
					<div class="option-header">
						<h5>ðŸ§ª GTEx Tissue Expression Analysis</h5>
						<span class="option-badge">Expression Data</span>
					</div>
					<div class="option-description">
						<p>Open the GTEx browser to explore gene expression patterns across human tissues. Visualize where your genes are most highly expressed and identify tissue-specific patterns using the official GTEx portal.</p>
					</div>
					<div class="option-details">
						<ul>
							<li>Expression across 54 human tissues</li>
							<li>Interactive heatmaps and plots</li>
							<li>Tissue-specific expression patterns</li>
							<li>Comparative analysis between genes</li>
						</ul>
					</div>
					<div class="option-actions">
				<button 
							@click="exploreGTExExpression" 
							class="btn btn-primary option-btn"
							:disabled="!manualGenes.trim() || getGeneCount() > 50"
						>
							Open GTEx Browser
				</button>
						<span class="option-note">Max 50 genes â€¢ Opens in new tab</span>
					</div>
				</div>

				<!-- Option 3: Playbook Workflow Builder -->
				<div class="gene-option-card">
					<div class="option-header">
						<h5>ðŸ”¬ Explore genes in Playbook Workflow Builder</h5>
						<span class="option-badge">Workflow Analysis</span>
					</div>
					<div class="option-description">
						<p>Open the Playbook Workflow Builder to perform comprehensive gene set enrichment analysis across multiple CFDE databases. The workflow automatically analyzes your genes against 7 different databases and generates interactive visualizations.</p>
					</div>
					<div class="option-details">
						<ul>
							<li><strong>GTEx Tissues V8 2023:</strong> Tissue expression signatures</li>
							<li><strong>LINCS L1000:</strong> Chemical perturbation signatures</li>
							<li><strong>IDG Drug Targets 2022:</strong> Drug target analysis</li>
							<li><strong>HuBMAP ASCTplusB 2022:</strong> Cell type biomarkers</li>
							<li><strong>GlyGen 2022:</strong> Glycosylated protein analysis</li>
							<li><strong>Metabolomics Workbench 2022:</strong> Metabolite associations</li>
							<li><strong>MoTrPAC 2023:</strong> Exercise response signatures</li>
						</ul>
					</div>
					<div class="option-actions">
						<button 
							@click="enrichGenes" 
							class="btn btn-primary option-btn"
							:disabled="!manualGenes.trim()"
						>
							Open Playbook Builder
						</button>
						<span class="option-note">7 database analyses â€¢ Interactive charts â€¢ Opens in new tab</span>
					</div>
				</div>
			</div>
		</div>

		<!-- Gene Data Table -->
		<div v-if="geneData.length > 0" class="gene-data-table-section">
			<!-- Loading Banner -->
			<div v-if="scoringInProgress" class="gene-scoring-banner">
				<div class="banner-content">
					<span class="loading-spinner-small"></span>
					<span class="banner-text">Generating gene to hypothesis novelty and relevance scores... ({{ geneScoringElapsedTime }})</span>
				</div>
			</div>
			
			<div class="gene-data-header">
                        <label class="gene-data-label">Select genes to generate experiment plans</label>
	                </div>
				<small class="gene-data-description">
                        Review the gene associations below and select the genes you want to include in your experiment plan. 
                        Each selected gene will be used to generate targeted validation experiments.
                        <br><br>
                        <strong>Note:</strong> The 'Hypothesis Alignment' and 'Research Gap Score' shown in the table are generated by AI and represent how relevant/novel each gene is to your specific hypothesis. These are different from the genetic novelty score used for sorting the table, which is based on gene-to-phenotype associations.
				</small>
			
			<div class="table-container">
				<table class="gene-data-table">
					<thead>
						<tr>
                                    <th>
                                        
                                    </th>
                                    <th>Gene/Target</th>
                                    <th>Hypothesis Alignment</th>
                                    <th>Research Gap Score</th>
                                    <th :style="hasManualGenes ? 'width: 70%;' : 'width: 50%;'">Molecular Rationale</th>
                                    <th v-if="!hasManualGenes">Associations</th>
						</tr>
					</thead>
					<tbody>
                                <tr v-for="row in tableRows" :key="row.key">
                                    <!-- Gene row -->
                                    <template v-if="row.type === 'gene'">
                                        <td>
                                            <input 
                                                type="checkbox" 
                                                :value="row.item.gene"
                                                v-model="selectedGenes"
                                                class="gene-checkbox"
                                            />
                                        </td>
                                        <td>{{ row.item.gene }}</td>
							<td>
								<div class="relevance-cell">
                                                <div v-if="getRelevance(row.item.gene)" class="score-content" :class="{ 'high-score': getRelevance(row.item.gene).score >= 7 }">
                                                    <div class="score-value">{{ getRelevanceScore(row.item.gene) }}</div>
									</div>
									<span v-else-if="row.item.isManual && phenotypeSearch.trim()" class="loading-text">
										Loading...
									</span>
									<span v-else>TBD</span>
								</div>
							</td>
							<td>
								<div class="novelty-cell">
                                                <div v-if="getNovelty(row.item.gene)" class="score-content" :class="{ 'high-score': getNovelty(row.item.gene).score >= 7 }">
                                                    <div class="score-value">{{ getNoveltyScore(row.item.gene) }}</div>
									</div>
									<span v-else-if="row.item.isManual && phenotypeSearch.trim()" class="loading-text">
										Loading...
									</span>
									<span v-else>TBD</span>
								</div>
							</td>
							<td>
								<div class="reason-cell">
                                                <div v-if="getNovelty(row.item.gene)" class="reason-content">
                                                    {{ getNovelty(row.item.gene).context }}
									</div>
									<span v-else-if="row.item.isManual && phenotypeSearch.trim()" class="loading-text">
										Loading...
									</span>
									<span v-else>TBD</span>
								</div>
							</td>
                                        <td v-if="!hasManualGenes">
                                            <button 
                                                @click="toggleEvidenceView(row.item.gene)"
                                                class="view-button"
                                                :class="{ active: expandedGenes.includes(row.item.gene) }"
                                            >
                                                {{ expandedGenes.includes(row.item.gene) ? 'Hide' : 'View' }}
                                            </button>
                                        </td>
                                    </template>
                                    
                                    <!-- Evidence row -->
                                    <template v-else-if="row.type === 'evidence'">
                                        <td :colspan="hasManualGenes ? 5 : 6">
                                            <div class="evidence-subtable">
                                                <table class="evidence-table">
                                                    <thead>
                                                        <tr>
                                                            <th>Phenotype</th>
                                                            <th>Gene Set</th>
                                                            <th>Combined Genetic Support</th>
                                                            <th>Direct Genetic Support</th>
                                                            <th>Indirect Genetic Support</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr v-for="(evidence, index) in getEvidenceData(row.item)" :key="`${row.item.gene}-evidence-${index}`">
                                                                <td>{{ getPhenotypeDisplayNames(evidence.phenotype) }}</td>
                                                                <td>{{ evidence.gene_set }}</td>
                                                                <td>{{ evidence.combined ? evidence.combined.toFixed(2) : 'N/A' }}</td>
                                                                <td>{{ evidence.log_bf ? evidence.log_bf.toFixed(2) : 'N/A' }}</td>
                                                                <td>{{ evidence.prior ? evidence.prior.toFixed(2) : 'N/A' }}</td>
                                                            </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </td>
                                    </template>
						</tr>
					</tbody>
				</table>
				
				<!-- Pagination -->
                        <div class="pagination-container">
					<div class="pagination-info">
						Showing {{ (currentPage - 1) * itemsPerPage + 1 }} to {{ Math.min(currentPage * itemsPerPage, geneData.length) }} of {{ geneData.length }} entries
					</div>
					<div class="pagination-controls">
						<button 
							@click="goToFirstPage" 
							:disabled="currentPage === 1"
							class="pagination-btn first-last-btn"
							title="First page"
						>
							Â«Â«
						</button>
						<button 
							@click="previousPage" 
							:disabled="currentPage === 1"
							class="pagination-btn"
						>
							Previous
						</button>
						<span class="page-numbers">
							<button 
								v-for="page in visiblePages" 
								:key="page"
								@click="goToPage(page)"
								:class="['page-btn', { 'active': page === currentPage }]"
							>
								{{ page }}
							</button>
						</span>
						<button 
							@click="nextPage" 
							:disabled="currentPage === totalPages"
							class="pagination-btn"
						>
							Next
						</button>
						<button 
							@click="goToLastPage" 
							:disabled="currentPage === totalPages"
							class="pagination-btn first-last-btn"
							title="Last page"
						>
							Â»Â»
						</button>
					</div>
				</div>
			</div>
			
                </div>
				</div>
			</div>
		</div>

		</div>
	</div>
</template>

<script>
import Vue from "vue";
import { BootstrapVueIcons } from "bootstrap-vue";
import { createLLMClient } from "@/utils/llmClient";
import cfdeValidationUtils, { findPhenotypeByName, findPhenotypeById } from "@/utils/cfdeValidationUtils";
import drcUtils from "@/utils/drcUtils";

Vue.use(BootstrapVueIcons);

export default {
	props: ["sectionConfigs", "phenotypesInUse", "utilsBox"],
	components: {
	},
	data() {
		return {
            cfdeValidationUtils: cfdeValidationUtils,

			gene_novelty_prompt: `Generate a JSON array for up to 10 genes based on the hypothesis below.

**Hypothesis:** [INSERT YOUR HYPOTHESIS HERE]
**Genes:** [INSERT YOUR COMMA-SEPARATED GENE LIST HERE (MAX 10)]

**Task & JSON Model:** Respond **ONLY** with a valid JSON array. For each gene, provide numeric scores for novelty and relevance, and a single 'reason' field (max 25 words) that justifies both scores.

**Workflow:** Prioritize speed. Determine all scores/reasoning concurrently across the gene list.
***Reasoning Requirement: The 'reason' field must clearly link the gene's function to the hypothesis (relevance) AND contextualize the novelty score by classifying the gene's role (e.g., Core Functional Enzyme vs. Upstream Regulator vs. Accessory Factor), justifying its research standing.***
***If information is unavailable for a gene, set both scores to "N/A" and explain why in 'reason' (â‰¤25 words).***

Novelty Score (1=Highly Studied, 10=Poorly Studied).
Relevance Score (1=Low Relevance to Hypothesis, 10=Highly Relevant).

[
  {
    "gene": "<symbol>",
    "relevance_score": "<1-10 or N/A>",
    "novelty_score": "<1-10 or N/A>",
    "reason": "<max 25 words: justification for both scores>"
  },
  ...
]`,

               
            
            // UI state
            phenotypeSearch: '',
            geneSets: '',
            // COMMENTED OUT: Experimental parameters and experiment generation
            /*
            selectedAssayTypes: [],
            selectedCellTypes: [],
            selectedReadouts: [],
            selectedThroughput: '',
            selectedSpecies: '',
            selectedTimeBudget: '',
            experimentNotes: '',
            isGenerating: false,
            experimentResults: '',
            showExperimentSummary: false,
            generationStartTime: null,
            generationTimer: null,
            elapsedTime: '0:00',
            */
            selectedAssociationGroups: [],
            associationGroups: [],
            ignoreAssociations: false,
            // COMMENTED OUT: Dropdown states for experimental parameters
            /*
            showDropdowns: {
                assayTypes: false,
                cellTypes: false,
                readouts: false
            },
            */
            // Gene data table properties
            geneData: [],
            originalGeneData: [], // Store original data before merging
            fetchedGeneData: [], // Store fetched data before user adds to table
            currentPage: 1,
            itemsPerPage: 10,
            selectedGenes: [],
            // COMMENTED OUT: Gene experiment strategy
            // geneExperimentStrategy: 'individual', // 'individual' or 'all_together'
            // Gene novelty and relevance cache
            geneNovelty: {},
            geneRelevance: {},
            // Evidence view state
            expandedGenes: [],
            // Gene loading state
            isLoadingGenes: false,
            // Track if associations have been modified since last gene load
            associationsModified: false,
            // COMMENTED OUT: Citation popup state
            // showCitationPopup: false,
            // COMMENTED OUT: Configuration section state
            // showConfigurationSection: false,
			// Manual gene input state
			showManualGeneInput: false,
			manualGenes: '',
			// Hide associations input when genes come from URL
			hideAssociationsInput: false,
			// URL parameter choice dialog
			showUrlChoiceDialog: false,
			urlChoiceOptions: {
				associations: null,
				genes: null
			},
			// Gene scoring state
			isGeneratingScores: false,
			// Timer for gene scoring
			geneScoringStartTime: null,
			geneScoringTimer: null,
			geneScoringElapsedTime: '0:00',
			// Track scoring progress
			scoringInProgress: false,
			// Track which genes are currently being processed
			genesBeingProcessed: []
		};
	},
	modules: {
	},

	created() {
		this.getGeneNovelty = createLLMClient({
			llm: "openai",
			model: "gpt-5-mini",
			system_prompt: this.gene_novelty_prompt
		});

        this.buildExperiments = createLLMClient({
            llm: "openai",
            model: "gpt-5-mini",
            system_prompt: this.experiment_prompt
		});
	},

	mounted: async function () {
		// Reset scoring state on mount
		this.scoringInProgress = false;
		this.isGeneratingScores = false;
		this.geneScoringStartTime = null;
		this.geneScoringElapsedTime = '0:00';
		this.genesBeingProcessed = [];
		
		// Check for URL parameters and populate fields
		// Use nextTick to ensure utilsBox is fully loaded
		this.$nextTick(async () => {
			await this.initializeFromKeyParams();
		});
	},
	beforeDestroy() {
		// Clean up timer when component is destroyed
		this.clearGenerationTimer();
		this.clearGeneNoveltyTimer();
		this.clearGeneScoringTimer();
		// Clean up gene novelty timeout
		if (this.geneNoveltyTimeout) {
			clearTimeout(this.geneNoveltyTimeout);
		}
	},
	computed: {
		hasManualGenes() {
			return this.geneData.some(gene => gene.isManual === true);
		},
		hasHypothesis() {
			return this.phenotypeSearch && this.phenotypeSearch.trim() !== '';
		},
		searchPlanText() {
			let text = '<p>Your experiment plan will be created using the following approach:</p>';
			
			if (this.selectedGenes.length > 0 && this.phenotypeSearch.trim() !== '') {
				text += '<p><strong>Hypothesis + Selected Genes Strategy:</strong></p>';
				text += '<ol>';
				text += '<li><strong>Analyze hypothesis:</strong> ';
				text += `Process the provided hypothesis "${this.phenotypeSearch.trim()}" to identify key biological concepts and mechanisms.</li>`;
				
				text += '<li><strong>Generate gene-specific experiments:</strong> ';
				text += `Create ${this.selectedGenes.length} separate experiment protocol${this.selectedGenes.length > 1 ? 's' : ''} - one for each selected gene (${this.selectedGenes.join(', ')}) in combination with your hypothesis.</li>`;
				
				text += '<li><strong>Apply user preferences:</strong> ';
				if (this.selectedAssayTypes.length > 0 || this.selectedCellTypes.length > 0 || this.selectedReadouts.length > 0) {
					text += 'Incorporate selected assay types, cell types, and readouts into each gene-specific experiment design.</li>';
				} else {
					text += 'Design experiments using optimal assay types, cell types, and readouts for each gene validation target.</li>';
				}
				text += '</ol>';
			} else if (this.selectedGenes.length > 0) {
				text += '<p><strong>Selected Genes Strategy:</strong></p>';
				text += '<ol>';
				text += '<li><strong>Generate gene-specific experiments:</strong> ';
				text += `Create ${this.selectedGenes.length} separate experiment protocol${this.selectedGenes.length > 1 ? 's' : ''} - one for each selected gene (${this.selectedGenes.join(', ')}) to validate their biological functions.</li>`;
				
				text += '<li><strong>Apply user preferences:</strong> ';
				if (this.selectedAssayTypes.length > 0 || this.selectedCellTypes.length > 0 || this.selectedReadouts.length > 0) {
					text += 'Incorporate selected assay types, cell types, and readouts into each gene-specific experiment design.</li>';
				} else {
					text += 'Design experiments using optimal assay types, cell types, and readouts for each gene validation target.</li>';
				}
				text += '</ol>';
			} else if (this.phenotypeSearch.trim() !== '') {
				text += '<p><strong>Hypothesis-Only Strategy:</strong></p>';
				text += '<ol>';
				text += '<li><strong>Analyze hypothesis:</strong> ';
				text += `Process the provided hypothesis "${this.phenotypeSearch.trim()}" to identify key biological concepts and mechanisms.</li>`;
				
				text += '<li><strong>Build an experiment plan:</strong> ';
				text += 'Design targeted validation experiments to test the hypothesis and establish causal relationships.</li>';
				text += '</ol>';
			} else {
				text += '<p><em>Please provide a hypothesis and/or select genes to generate experiment plans.</em></p>';
			}
			
			// Additional context based on other selections
			if (this.selectedAssayTypes.length > 0) {
				text += '<p><strong>Assay Types:</strong> ';
				text += `Focus on ${this.selectedAssayTypes.map(at => at.split(':')[1] || '').join(', ')} experiments for validation.</p>`;
			}
			
			if (this.selectedReadouts.length > 0) {
				text += '<p><strong>Readouts:</strong> ';
				text += 'Target specific readouts: ' + this.selectedReadouts.join(', ') + ' for comprehensive analysis.</p>';
			}
			
			return text;
		},
		parsedExperimentResults() {
			if (this.isValidExperimentJSON(this.experimentResults)) {
				try {
					return JSON.parse(this.experimentResults).resultModel;
				} catch (error) {
					console.error('Error parsing experiment results:', error);
					return [];
				}
			}
			return [];
		},
		totalPages() {
			return Math.ceil(this.geneData.length / this.itemsPerPage);
		},
		paginatedGeneData() {
			const start = (this.currentPage - 1) * this.itemsPerPage;
			const end = start + this.itemsPerPage;
			return this.geneData.slice(start, end);
		},
		// Create rows with evidence for proper table structure
		tableRows() {
			const rows = [];
			this.paginatedGeneData.forEach(item => {
				// Add the main gene row
				rows.push({
					type: 'gene',
					item: item,
					key: `${item.gene}-${item.combined || 0}`
				});
				
				// Add evidence row if expanded and not manual genes
				if (!this.hasManualGenes && this.expandedGenes.includes(item.gene)) {
					rows.push({
						type: 'evidence',
						item: item,
						key: `${item.gene}-evidence-${item.combined || 0}`
					});
				}
			});
			return rows;
		},
		visiblePages() {
			const pages = [];
			const total = this.totalPages;
			const current = this.currentPage;
			
			// Show up to 5 page numbers
			let start = Math.max(1, current - 2);
			let end = Math.min(total, start + 4);
			
			// Adjust start if we're near the end
			if (end - start < 4) {
				start = Math.max(1, end - 4);
			}
			
			for (let i = start; i <= end; i++) {
				pages.push(i);
			}
			
			return pages;
		},
		allGenesSelected() {
			const geneRows = this.tableRows.filter(row => row.type === 'gene');
			return geneRows.length > 0 && 
				   geneRows.every(row => this.selectedGenes.includes(row.item.gene));
		},
		hasOnlyOneAssociation() {
			// Check if there's only one association in the geneSets
			if (!this.geneSets.trim()) {
				return false;
			}
			
			const lines = this.geneSets.split('\n').filter(line => line.trim());
			return lines.length === 1;
		},
		hasOnlyOneAssociationFromData() {
			// Check if there's only one association based on the actual gene data
			// Count unique phenotype-geneSet combinations in originalGeneData
			const associations = new Set();
			this.originalGeneData.forEach(item => {
				if (item.phenotype && item.gene_set) {
					associations.add(`${item.phenotype}-${item.gene_set}`);
				}
			});
			return associations.size === 1;
		},
	},
		watch: {
			utilsBox: {
				handler(newVal) {
					if (newVal && newVal.keyParams) {
						this.initializeFromKeyParams();
					}
				},
				immediate: true
			},
			geneSets(newVal, oldVal) {
				// Track when associations are modified
				if (oldVal !== undefined && newVal !== oldVal) {
					// If geneSets is cleared, reset the modified flag
					if (!newVal.trim()) {
						this.associationsModified = false;
						console.log('Associations cleared, Load Genes button hidden');
					} else {
						this.associationsModified = true;
						console.log('Associations modified, Load Genes button should appear');
					}
				}
			},
			currentPage() {
				// Generate scores for genes on current page that don't have scores yet
				this.generateScoresForCurrentPage();
			},
	},
	methods: {
		getPhenotypeById(phenotypeId) {
			return findPhenotypeById(phenotypeId);
		},
		calculatePPA(x) {
			// PPA formula: exp(x + log(5/95))/(1 + exp(x + log(5/95)))
			const logOdds = Math.log(5/95);
			const exponent = x + logOdds;
			const expValue = Math.exp(exponent);
			return expValue / (1 + expValue);
		},
		getPhenotypeDisplayNames(phenotypeString) {
			if (!phenotypeString) return '';
			
			// Split by comma and convert each phenotype ID to human-readable name
			const phenotypeIds = phenotypeString.split(', ').map(id => id.trim());
			const displayNames = phenotypeIds.map(id => {
				const humanReadableName = findPhenotypeById(id);
				return humanReadableName || id; // Fallback to original ID if not found
			});
			
			return displayNames.join(', ');
		},
		getNovelty(geneSymbol) {
			if (!geneSymbol) return null;
			return this.geneNovelty[geneSymbol] || null;
		},
		getRelevance(geneSymbol) {
			if (!geneSymbol) return null;
			return this.geneRelevance[geneSymbol] || null;
		},
		getNoveltyScore(geneSymbol) {
			const novelty = this.getNovelty(geneSymbol);
			return novelty ? `${novelty.score}/10` : 'N/A';
		},
		getRelevanceScore(geneSymbol) {
			const relevance = this.getRelevance(geneSymbol);
			return relevance ? `${relevance.score}/10` : 'N/A';
		},
		toggleEvidenceView(geneSymbol) {
			const index = this.expandedGenes.indexOf(geneSymbol);
			if (index > -1) {
				this.expandedGenes.splice(index, 1);
			} else {
				this.expandedGenes.push(geneSymbol);
			}
		},
		getEvidenceData(gene) {
			// Return the original evidence data for this gene before merging
			// Filter originalGeneData to get all entries for this specific gene
			const evidenceData = this.originalGeneData.filter(item => item.gene === gene.gene);
			
			// Sort by combined score (descending) to show highest scores first
			evidenceData.sort((a, b) => (b.combined || 0) - (a.combined || 0));
			
			return evidenceData;
		},
		// COMMENTED OUT: Automatic novelty querying - will be replaced with manual trigger
		/*
		async getGeneNoveltyForCurrentPage() {
			// Clear any existing timeout
			if (this.geneNoveltyTimeout) {
				clearTimeout(this.geneNoveltyTimeout);
			}
			
			// Debounce the request to prevent rapid successive calls
			this.geneNoveltyTimeout = setTimeout(() => {
				this._executeGeneNoveltyRequest();
			}, 300); // 300ms debounce
		},
		async _executeGeneNoveltyRequest() {
			// Prevent concurrent requests
			if (this.isGettingGeneNovelty) {
				console.log('Gene novelty request already in progress, skipping...');
				return;
			}
			
			// Get genes on current page that don't have novelty yet
			const currentPageGenes = this.paginatedGeneData;
			const genesNeedingNovelty = currentPageGenes.filter(gene =>
				!this.geneNovelty[gene.gene] && gene.gene
			);

			if (genesNeedingNovelty.length === 0) {
				return; // All genes on this page already have novelty
			}

			// Limit to 10 genes as per prompt constraints
			const genesToProcess = genesNeedingNovelty.slice(0, 10);

			if (genesToProcess.length === 0) {
				return;
			}

			this.isGettingGeneNovelty = true;
			this.geneNoveltyStartTime = Date.now();
			this.geneNoveltyElapsedTime = '0:00';

			// Start timer to update elapsed time every second
			this.geneNoveltyTimer = setInterval(() => {
				if (this.isGettingGeneNovelty && this.geneNoveltyStartTime) {
					const elapsed = Math.floor((Date.now() - this.geneNoveltyStartTime) / 1000);
					const minutes = Math.floor(elapsed / 60);
					const seconds = elapsed % 60;
					this.geneNoveltyElapsedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
				}
			}, 1000);

			try {
				// Prepare the prompt
				const geneList = genesToProcess.map(gene => gene.gene).join(', ');
				const prompt = this.gene_novelty_prompt
					.replace('[INSERT YOUR HYPOTHESIS HERE]', this.phenotypeSearch.trim() || 'No specific hypothesis provided')
					.replace('[INSERT YOUR COMMA-SEPARATED GENE LIST HERE (MAX 10)]', geneList);

				// Call the LLM
				this.getGeneNovelty.sendPrompt({
					userPrompt: prompt,
					onResponse: (response) => {
						try {
							// Parse the JSON response
							const noveltyData = JSON.parse(response);
							
							// Update the geneNovelty and geneRelevance cache
							noveltyData.forEach(item => {
								if (item.gene) {
									// Handle novelty score
									if (item.novelty_score !== undefined) {
										this.$set(this.geneNovelty, item.gene, {
											score: item.novelty_score,
											context: item.reason || 'No context provided'
										});
									}
									
									// Handle relevance score
									if (item.relevance_score !== undefined) {
										this.$set(this.geneRelevance, item.gene, {
											score: item.relevance_score,
											context: item.reason || 'No context provided'
										});
									}
								}
							});
							
							console.log(`Gene novelty updated for ${noveltyData.length} genes`);
							
						} catch (error) {
							console.error('Error parsing gene novelty response:', error);
						} finally {
							this.isGettingGeneNovelty = false;
							this.clearGeneNoveltyTimer();
						}
					},
					onError: (error) => {
						console.error('Error getting gene novelty:', error);
						this.isGettingGeneNovelty = false;
						this.clearGeneNoveltyTimer();
					},
					onEnd: () => {
						this.isGettingGeneNovelty = false;
						this.clearGeneNoveltyTimer();
					}
				});
			} catch (error) {
				console.error('Error preparing gene novelty request:', error);
				this.isGettingGeneNovelty = false;
				this.clearGeneNoveltyTimer();
			}
		},
		*/
		toggleAllGenes() {
			const geneRows = this.tableRows.filter(row => row.type === 'gene');
			if (this.allGenesSelected) {
				// Unselect all genes on current page
				geneRows.forEach(row => {
					const index = this.selectedGenes.indexOf(row.item.gene);
					if (index > -1) {
						this.selectedGenes.splice(index, 1);
					}
				});
			} else {
				// Select all genes on current page
				geneRows.forEach(row => {
					if (!this.selectedGenes.includes(row.item.gene)) {
						this.selectedGenes.push(row.item.gene);
					}
				});
			}
		},
		removeGene(gene) {
			const index = this.selectedGenes.indexOf(gene);
			if (index > -1) {
				this.selectedGenes.splice(index, 1);
			}
		},
		clearSelectedGenes() {
			this.selectedGenes = [];
		},
		exportSelectedGenes() {
			if (this.selectedGenes.length === 0) {
				alert('No genes selected to export.');
				return;
			}
			
			// Create a simple text file with selected genes
			const content = this.selectedGenes.join('\n');
			const blob = new Blob([content], { type: 'text/plain' });
			const url = window.URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.href = url;
			link.download = 'selected_genes.txt';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			window.URL.revokeObjectURL(url);
		},
		sortAndGroupGeneData(geneData) {
			// First, sort by Combined score (descending - highest first)
			const sortedByCombined = geneData.sort((a, b) => {
				const combinedA = a.combined || 0;
				const combinedB = b.combined || 0;
				return combinedB - combinedA; // Descending order
			});
			
			// Group by Gene and merge rows
			const groupedByGene = {};
			const result = [];
			
			sortedByCombined.forEach(item => {
				const gene = item.gene;
				if (!groupedByGene[gene]) {
					// First occurrence of this gene - keep this row as the base
					groupedByGene[gene] = {
						...item,
						phenotypes: new Set([item.phenotype]),
						geneSets: new Set([item.gene_set])
					};
				} else {
					// Merge with existing gene data
					groupedByGene[gene].phenotypes.add(item.phenotype);
					groupedByGene[gene].geneSets.add(item.gene_set);
					
					// Update other fields if this row has higher combined score
					const currentCombined = groupedByGene[gene].combined || 0;
					const newCombined = item.combined || 0;
					if (newCombined > currentCombined) {
						// Update with the row that has higher combined score
						Object.assign(groupedByGene[gene], {
							combined: item.combined,
							prior: item.prior,
							beta: item.beta,
							log_bf: item.log_bf,
							source: item.source,
							summary: item.summary
						});
					}
				}
			});
			
			// Convert Sets back to arrays and create final result
			Object.keys(groupedByGene).forEach(gene => {
				const mergedItem = groupedByGene[gene];
				
				// Calculate PPA scores for this gene
				const logBf = mergedItem.log_bf || 0;
				const prior = mergedItem.prior || 0;
				const directPPA = this.calculatePPA(logBf);
				const indirectPPA = this.calculatePPA(prior);
				
				result.push({
					...mergedItem,
					phenotype: Array.from(mergedItem.phenotypes).join(', '),
					gene_set: Array.from(mergedItem.geneSets).join(', '),
					// Add PPA calculations
					directPPA: directPPA,
					indirectPPA: indirectPPA,
					// Remove the temporary Set properties
					phenotypes: undefined,
					geneSets: undefined
				});
			});
			
			// Sort the final result by Combined score (descending)
			result.sort((a, b) => {
				const combinedA = a.combined || 0;
				const combinedB = b.combined || 0;
				return combinedB - combinedA;
			});
			
			
			return result;
		},
		parseAssociations(associationsString) {
			// Split by semicolon to get individual rows
			const rows = associationsString.split(';').map(row => row.trim());
			
			let formatted = '';
			
			// Process each row
			rows.forEach(row => {
				// Split by comma to get phenotype, gene set, and source
				const parts = row.split(',').map(part => part.trim());
				
				// Ensure we have at least 3 parts, pad with empty strings if needed
				const phenotype = parts[0] || '';
				const geneSet = parts[1] || '';
				const source = parts[2] || '';
				
				// Add comma-separated row
				formatted += `${phenotype}, ${geneSet}, ${source}\n`;
			});
			
			return formatted.trim();
		},
		parseTextareaContent(textareaContent) {
			// If ignore associations is enabled, return empty string
			if (this.ignoreAssociations) {
				return '';
			}
			
			// Check if content is formatted as CSV (has comma-separated values)
			if (textareaContent.includes(',')) {
				// Group associations by phenotype + source
				const lines = textareaContent.split('\n').filter(line => line.trim());
				const groups = {};
				
				// Process all lines (no header row assumption for CSV)
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i].trim();
					if (line) {
						const parts = line.split(',').map(part => part.trim());
						if (parts.length >= 3) {
							const phenotype = parts[0] || 'N/A';
							const geneSet = parts[1] || 'N/A';
							const source = parts[2] || 'N/A';
							
							const groupKey = `${phenotype} + ${source}`;
							
							// Only include groups that are selected
							if (this.selectedAssociationGroups.length === 0 || this.selectedAssociationGroups.includes(groupKey)) {
								if (!groups[groupKey]) {
									groups[groupKey] = {
										phenotype: phenotype,
										source: source,
										geneSets: []
									};
								}
								groups[groupKey].geneSets.push(geneSet);
							}
						}
					}
				}
				
				// Format grouped associations for the LLM
				let formatted = 'PHENOTYPE-GENE SET ASSOCIATIONS (grouped by phenotype + source):\n\n';
				
				Object.keys(groups).forEach(groupKey => {
					const group = groups[groupKey];
					formatted += `**Group: ${groupKey}**\n`;
					formatted += `- Phenotype: ${group.phenotype}\n`;
					formatted += `- Source: ${group.source}\n`;
					formatted += `- Gene Sets: ${group.geneSets.join(', ')}\n\n`;
				});
				
				return formatted.trim();
			} else {
				// If not a CSV format, return as-is with some basic formatting
				return textareaContent.split('\n').map(line => `- ${line}`).join('\n');
			}
		},
		async initializeFromKeyParams() {
			// Check if keyParams exist and populate fields
			if (this.utilsBox && this.utilsBox.keyParams) {
				
				let hypothesisFound = false;
				let hasAssociations = false;
				let hasGenes = false;
				
				// Populate hypothesis field if keyParams['hypothesis'] exists
				if (this.utilsBox.keyParams['hypothesis'] && typeof this.utilsBox.keyParams['hypothesis'] === 'string') {
					this.phenotypeSearch = this.utilsBox.keyParams['hypothesis'];
					hypothesisFound = true;
				}
				
				// Check for associations parameter
				if (this.utilsBox.keyParams['geneSets'] && typeof this.utilsBox.keyParams['geneSets'] === 'string') {
					this.geneSets = this.utilsBox.keyParams['geneSets'];
					hasAssociations = true;
				}
				
				// Check for associations parameter (alternative)
				if (this.utilsBox.keyParams['associations'] && typeof this.utilsBox.keyParams['associations'] === 'string') {
					this.geneSets = this.parseAssociations(this.utilsBox.keyParams['associations']);
					hasAssociations = true;
				}
				
				// Check for genes parameter
				if (this.utilsBox.keyParams['genes'] && typeof this.utilsBox.keyParams['genes'] === 'string') {
					const geneList = this.utilsBox.keyParams['genes'].split(',').map(gene => gene.trim()).filter(gene => gene);
					if (geneList.length > 0) {
						hasGenes = true;
						this.urlChoiceOptions.genes = geneList;
					}
				}
				
				// If both associations and genes are present, show choice dialog
				if (hasAssociations && hasGenes) {
					this.urlChoiceOptions.associations = this.geneSets;
					this.showUrlChoiceDialog = true;
					return; // Wait for user choice
				}
				
				// If only associations, proceed with associations
				if (hasAssociations && !hasGenes) {
					await this.fetchGenesFromAssociations();
				}
				
				// If only genes, proceed with genes
				if (!hasAssociations && hasGenes) {
					await this.addGenesFromUrl(this.urlChoiceOptions.genes);
				}
				
				// If hypothesis was found, open the configure panel instead of generating draft
				if (hypothesisFound) {
					// Configuration panel is now always visible
					// Scroll disabled to allow users to see genes getting fetched
					// this.$nextTick(() => {
					// 	setTimeout(() => {
					// 		const configurePanel = document.getElementById('planner-search-ui');
					// 		if (configurePanel) {
					// 			configurePanel.scrollIntoView({ 
					// 				behavior: 'smooth', 
					// 				block: 'start',
					// 				inline: 'nearest'
					// 			});
					// 		}
					// 	}, 500); // Wait for panel to open
					// });
				}
			}
		},
		async loadGenesFromAssociations() {
			try {
				this.isLoadingGenes = true;
				await this.fetchGenesFromAssociations();
				// Reset the modified flag after successful gene loading
				this.associationsModified = false;
				console.log('Genes loaded successfully, associations modified flag reset');
			} catch (error) {
				console.error('Error loading genes from associations:', error);
			} finally {
				this.isLoadingGenes = false;
			}
		},
		toggleManualGeneInput() {
			this.showManualGeneInput = !this.showManualGeneInput;
			if (!this.showManualGeneInput) {
				this.manualGenes = '';
			}
		},
		switchToAssociationsInput() {
			this.showManualGeneInput = false;
			this.manualGenes = '';
			this.hideAssociationsInput = false;
			this.fetchedGeneData = [];
		},
		clearGeneInput() {
			this.manualGenes = '';
			this.fetchedGeneData = [];
			// Reset scoring state
			this.scoringInProgress = false;
			this.isGeneratingScores = false;
			this.genesBeingProcessed = [];
			this.clearGeneScoringTimer();
		},
		async addManualGenes() {
			// Check if there are genes in the manual-genes field
			if (!this.manualGenes.trim()) {
				alert('Please enter gene symbols in the gene input field.');
				return;
			}
			
			// Parse the manual genes input
			const geneList = this.manualGenes.split(',').map(gene => gene.trim()).filter(gene => gene);
			
			if (geneList.length === 0) {
				alert('Please enter valid gene symbols separated by commas.');
				return;
			}
			
			// Check for duplicate genes
			const existingGenes = this.geneData.map(g => g.gene);
			const duplicateGenes = geneList.filter(gene => existingGenes.includes(gene));
			if (duplicateGenes.length > 0) {
				alert(`The following genes are already in the table: ${duplicateGenes.join(', ')}. Please remove duplicates and try again.`);
				return;
			}
			
			// Check if we have fetched gene data that matches the input
			let genesToAdd = [];
			
			if (this.fetchedGeneData.length > 0) {
				// Use fetched data if available and genes match
				const fetchedGenes = this.fetchedGeneData.map(g => g.gene);
				const matchingGenes = geneList.filter(gene => fetchedGenes.includes(gene));
				
				if (matchingGenes.length === geneList.length) {
					// All genes match fetched data, use the full fetched data
					genesToAdd = this.fetchedGeneData;
					console.log('Using fetched gene data for table');
				} else {
					// Some genes don't match, create manual entries
					genesToAdd = geneList.map(gene => ({
				gene: gene,
						log_bf: null,
						prior: null,
						combined: null,
						directPPA: null,
						indirectPPA: null,
				source: 'Manual Input',
						phenotype: 'Manual Input',
						isManual: true
					}));
					console.log('Using manual gene data for table');
				}
			} else {
				// No fetched data, create manual entries
				genesToAdd = geneList.map(gene => ({
					gene: gene,
					log_bf: null,
					prior: null,
					combined: null,
					directPPA: null,
					indirectPPA: null,
					source: 'Manual Input',
					phenotype: 'Manual Input',
					isManual: true
				}));
				console.log('Using manual gene data for table');
			}
			
			// Add to existing gene data
			this.geneData = [...this.geneData, ...genesToAdd];
			this.originalGeneData = [...this.originalGeneData, ...genesToAdd];
			
			// Clear the gene input field and fetched data after adding
			this.manualGenes = '';
			this.fetchedGeneData = [];
			
			console.log(`Added ${genesToAdd.length} genes to table: ${geneList.join(', ')}`);
		},
		async getNoveltyForManualGenes(geneList, onComplete = null) {
			try {
				// Limit to 10 genes as per prompt constraints
				const genesToProcess = geneList.slice(0, 10);
				
				if (genesToProcess.length === 0) {
					return;
				}
				
				// Prepare the prompt
				const prompt = this.gene_novelty_prompt
					.replace('[INSERT YOUR HYPOTHESIS HERE]', this.phenotypeSearch.trim() || 'No specific hypothesis provided')
					.replace('[INSERT YOUR COMMA-SEPARATED GENE LIST HERE (MAX 10)]', genesToProcess.join(', '));
				
				// Call the LLM
				this.getGeneNovelty.sendPrompt({
					userPrompt: prompt,
					onResponse: (response) => {
						try {
							// Parse the JSON response
							const noveltyData = JSON.parse(response);
							
							// Update the geneNovelty and geneRelevance cache
							noveltyData.forEach(item => {
								if (item.gene) {
									// Handle novelty score
									if (item.novelty_score !== undefined) {
										this.$set(this.geneNovelty, item.gene, {
											score: item.novelty_score,
											context: item.reason || 'No context provided'
										});
									}
									
									// Handle relevance score
									if (item.relevance_score !== undefined) {
										this.$set(this.geneRelevance, item.gene, {
											score: item.relevance_score,
											context: item.reason || 'No context provided'
										});
									}
								}
							});
							
							
						} catch (error) {
							console.error('Error parsing manual gene novelty response:', error);
						}
					},
					onError: (error) => {
						console.error('Error getting novelty for manual genes:', error);
						// Call completion callback even on error
						if (onComplete) {
							onComplete();
						}
					},
					onEnd: () => {
						// Check if all manual genes have been scored
						if (this.checkAllGenesScored()) {
							this.scoringInProgress = false;
							this.isGeneratingScores = false;
							this.clearGeneScoringTimer();
						}
						
						// Call completion callback when done
						if (onComplete) {
							onComplete();
						}
					}
				});
			} catch (error) {
				console.error('Error preparing manual gene novelty request:', error);
			}
		},
		
		async addGenesFromUrl(geneList) {
			try {
				// Hide associations input when genes come from URL
				this.hideAssociationsInput = true;
				
				// Populate the gene input field with URL genes
				this.manualGenes = geneList.join(', ');
				
				console.log(`Genes from URL parameters populated in gene input: ${geneList.join(', ')}`);
				console.log('Table will not show until user clicks Add Genes');
				
			} catch (error) {
				console.error('Error adding genes from URL parameters:', error);
			}
		},
		
		async chooseAssociations() {
			this.showUrlChoiceDialog = false;
			this.geneSets = this.urlChoiceOptions.associations;
			await this.fetchGenesFromAssociations();
		},
		
		async chooseGenes() {
			this.showUrlChoiceDialog = false;
			this.hideAssociationsInput = true;
			await this.addGenesFromUrl(this.urlChoiceOptions.genes);
		},
		
		cancelUrlChoice() {
			this.showUrlChoiceDialog = false;
			// Clear the options
			this.urlChoiceOptions.associations = null;
			this.urlChoiceOptions.genes = null;
		},
		async fetchGenesFromAssociations() {
			try {
				console.log('Starting fetchGenesFromAssociations with geneSets:', this.geneSets);
				// Parse the gene sets data to extract phenotype and gene set information
				const lines = this.geneSets.split('\n').filter(line => line.trim());
				console.log('Parsed lines:', lines);
				const geneQueries = [];
				
				// Extract phenotype and gene set pairs for API queries
				for (const line of lines) {
					const parts = line.split(',').map(part => part.trim());
					console.log('Processing line:', line, 'Parts:', parts);
					if (parts.length >= 2) {
						const phenotype = findPhenotypeByName(parts[0]);
						const geneSet = parts[1];
						console.log('Phenotype lookup:', parts[0], '->', phenotype);
						if (phenotype && geneSet) {
							geneQueries.push({ phenotype, geneSet });
						} else {
							console.log('Skipping line - phenotype or geneSet missing:', { phenotype, geneSet });
						}
					}
				}
				
				console.log('Gene queries to process:', geneQueries);
				
				// Fetch genes for each phenotype-gene set pair
				const allGenes = new Set();
				const allGeneData = [];
				
				for (const query of geneQueries) {
					try {
						const url = `https://cfde-dev.hugeampkpnbi.org/api/bio/query/pigean-joined-gene-set?q=${encodeURIComponent(query.phenotype)},${encodeURIComponent(query.geneSet)},cfde`;
						
						const response = await fetch(url);
						
						const data = await response.json();
						
						// Extract genes and full data from the response
						console.log(`API response for ${query.phenotype}-${query.geneSet}:`, data);
						if (data.data && Array.isArray(data.data)) {
							data.data.forEach(item => {
								if (item.gene) {
									allGenes.add(item.gene);
									allGeneData.push(item);
								}
							});
							console.log(`Found ${data.data.length} genes for ${query.phenotype}-${query.geneSet}`);
						} else {
							console.log(`No data found for ${query.phenotype}-${query.geneSet}`);
						}
					} catch (error) {
						console.error(`âŒ Error fetching genes for ${query.phenotype}-${query.geneSet}:`, error);
					}
				}
				
				// Store original data before merging (no prefiltering)
				this.originalGeneData = allGeneData;
				
				// Sort by Combined score (descending) first, then group by Gene
				const sortedAndGroupedData = this.sortAndGroupGeneData(allGeneData);
				
				// Store the fetched gene data for later use (don't populate table yet)
				this.fetchedGeneData = sortedAndGroupedData;
				
				// Populate the gene input field with fetched genes
				const geneSymbols = sortedAndGroupedData.map(g => g.gene).join(', ');
				this.manualGenes = geneSymbols;
				
				console.log('Genes fetched successfully and populated in input field:', {
					originalCount: allGeneData.length,
					groupedCount: sortedAndGroupedData.length,
					genes: sortedAndGroupedData.map(g => g.gene),
					populatedGeneInput: geneSymbols,
					note: 'Table will not show until user clicks Add Genes'
				});
				
			} catch (error) {
				console.error('Error fetching genes from associations:', error);
			}
		},
		previousPage() {
			if (this.currentPage > 1) {
				this.currentPage--;
			}
		},
		nextPage() {
			if (this.currentPage < this.totalPages) {
				this.currentPage++;
			}
		},
		goToPage(page) {
			if (page >= 1 && page <= this.totalPages) {
				this.currentPage = page;
			}
		},
		goToFirstPage() {
			this.currentPage = 1;
		},
		goToLastPage() {
			this.currentPage = this.totalPages;
		},
		removeAssayType(assayType) {
			this.selectedAssayTypes = this.selectedAssayTypes.filter(a => a !== assayType);
		},
		removeCellType(cellType) {
			this.selectedCellTypes = this.selectedCellTypes.filter(c => c !== cellType);
		},
		removeReadout(readout) {
			this.selectedReadouts = this.selectedReadouts.filter(r => r !== readout);
		},
		// Removed collapse functionality
		// COMMENTED OUT: draftValidationPlan method
		/*
		draftValidationPlan() {
			// Show the experiment plan summary section
			this.showExperimentSummary = true;
			
			// Generate experiment plan summary
			
			// Collect and validate the current configuration
			const config = {
				hypothesisSearch: this.phenotypeSearch,
				geneSets: this.geneSets,
				assayTypes: this.selectedAssayTypes,
				cellTypes: this.selectedCellTypes,
				readouts: this.selectedReadouts,
				throughput: this.selectedThroughput,
				species: this.selectedSpecies,
				timeBudget: this.selectedTimeBudget,
				notes: this.experimentNotes
			};
			
			
			// Validate that we have the required inputs
			if (!this.phenotypeSearch.trim() && this.selectedGenes.length === 0) {
				alert('Please provide a hypothesis and/or select genes to generate experiment plans.');
				return;
			}
			
			// Show gene selection status
			if (this.selectedGenes.length > 0) {
				console.log(`Selected ${this.selectedGenes.length} genes for experiment generation: ${this.selectedGenes.join(', ')}`);
			}
			
			// Wait for collapse animation to complete, then scroll to draft section
			this.$nextTick(() => {
				setTimeout(() => {
					const draftSection = document.getElementById('planner-search-draft');
					if (draftSection) {
						draftSection.scrollIntoView({ 
							behavior: 'smooth', 
							block: 'start',
							inline: 'nearest'
						});
					}
				}, 1200); // Wait for collapse animation to complete
			});
			
			// TODO: Call different APIs based on whether hypothesis search is provided
			// API 1: For hypothesis/phenotype search terms
			// API 2: For program-based search
		},
		*/
		onIgnoreAssociationsChange() {
			// When ignore associations is checked, clear selected groups
			if (this.ignoreAssociations) {
				this.selectedAssociationGroups = [];
			} else {
				// When unchecked, auto-select all groups
				this.selectedAssociationGroups = this.associationGroups.map(group => group.groupKey);
			}
		},
		populateAssociationGroups() {
			// Clear existing groups
			this.associationGroups = [];
			
			if (!this.geneSets.trim()) {
				return;
			}
			
			const textareaContent = this.geneSets.trim();
			
			// Check if content is formatted as CSV (has comma-separated values)
			if (textareaContent.includes(',')) {
				// Group associations by phenotype + source
				const lines = textareaContent.split('\n').filter(line => line.trim());
				const groups = {};
				
				// Process all lines (no header row assumption for CSV)
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i].trim();
					if (line) {
						const parts = line.split(',').map(part => part.trim());
						if (parts.length >= 3) {
							const phenotype = parts[0] || 'N/A';
							const geneSet = parts[1] || 'N/A';
							const source = parts[2] || 'N/A';
							
							const groupKey = `${phenotype} + ${source}`;
							if (!groups[groupKey]) {
								groups[groupKey] = {
									phenotype: phenotype,
									source: source,
									geneSets: []
								};
							}
							groups[groupKey].geneSets.push(geneSet);
						}
					}
				}
				
				// Convert groups object to array
				Object.keys(groups).forEach(groupKey => {
					const group = groups[groupKey];
					this.associationGroups.push({
						groupKey: groupKey,
						phenotype: group.phenotype,
						source: group.source,
						geneSets: group.geneSets
					});
				});
			}
		},
		resetAllSelections() {
			// Reset all selections
			this.selectedAssayTypes = [];
			this.selectedCellTypes = [];
			this.selectedReadouts = [];
			this.selectedThroughput = '';
			this.selectedSpecies = '';
			this.selectedTimeBudget = '';
			this.experimentNotes = '';
			this.phenotypeSearch = '';
			this.geneSets = '';
			this.selectedAssociationGroups = [];
			this.associationGroups = [];
			this.ignoreAssociations = false;
			this.selectedGenes = [];
			this.experimentResults = '';
			this.isGenerating = false;
			this.showExperimentSummary = false;
			// Reset associations modified flag
			this.associationsModified = false;
			// Reset gene scoring state
			this.scoringInProgress = false;
			this.isGeneratingScores = false;
			this.genesBeingProcessed = [];
			this.clearGenerationTimer();
			this.clearGeneScoringTimer();
		},
		extractSystemPrompt() {
			return "You are a system for extracting and processing phenotype-gene associations from research queries.";
		},
		// COMMENTED OUT: experimentPrompt method
		/*
		experimentPrompt() {
			// Build the experiment prompt with captured search draft values
			let prompt = this.experiment_prompt;
			
			// Add search context information
			prompt += '\n\n**Current Search Context:**\n';
			
			if (this.phenotypeSearch.trim() !== '') {
				prompt += `**Hypothesis:** ${this.phenotypeSearch.trim()}\n`;
			}
			
			if (this.selectedGenes.length > 0) {
				prompt += `**Selected Genes:** ${this.selectedGenes.join(', ')}\n`;
			}
			
			
			if (this.selectedAssayTypes.length > 0) {
				prompt += `**Selected Assay Types:** ${this.selectedAssayTypes.map(at => at.split(':')[1] || '').join(', ')}\n`;
			}
			
			if (this.selectedCellTypes.length > 0) {
				prompt += `**Selected Cell Types:** ${this.selectedCellTypes.map(ct => ct.split(':').pop() || '').join(', ')}\n`;
			}
			
			if (this.selectedReadouts.length > 0) {
				prompt += `**Selected Readouts:** ${this.selectedReadouts.join(', ')}\n`;
			}
			
			if (this.selectedThroughput) {
				prompt += `**Throughput:** ${this.selectedThroughput}\n`;
			}
			
			if (this.selectedSpecies) {
				prompt += `**Species Constraints:** ${this.selectedSpecies}\n`;
			}
			
			if (this.selectedTimeBudget) {
				prompt += `**Time Budget:** ${this.selectedTimeBudget}\n`;
			}
			
			if (this.experimentNotes.trim() !== '') {
				prompt += `**Additional Notes:** ${this.experimentNotes.trim()}\n`;
			}
			
			return prompt;
		},
		// COMMENTED OUT: experimentPromptGenes method
		/*
		experimentPromptGenes() {
			// Build the experiment prompt for combined gene experiments
			let prompt = this.experiment_prompt_genes;
			
			// Add search context information
			prompt += '\n\n**Current Search Context:**\n';
			
			if (this.phenotypeSearch.trim() !== '') {
				prompt += `**Hypothesis:** ${this.phenotypeSearch.trim()}\n`;
			}
			
			if (this.selectedGenes.length > 0) {
				prompt += `**Selected Genes (ALL TOGETHER):** ${this.selectedGenes.join(', ')}\n`;
				prompt += `**Strategy:** Generate ONE comprehensive experiment that tests all genes together\n`;
			}
			
			if (this.selectedAssayTypes.length > 0) {
				prompt += `**Selected Assay Types:** ${this.selectedAssayTypes.map(at => at.split(':')[1] || '').join(', ')}\n`;
			}
			
			if (this.selectedCellTypes.length > 0) {
				prompt += `**Selected Cell Types:** ${this.selectedCellTypes.map(ct => ct.split(':').pop() || '').join(', ')}\n`;
			}
			
			if (this.selectedReadouts.length > 0) {
				prompt += `**Selected Readouts:** ${this.selectedReadouts.join(', ')}\n`;
			}
			
			if (this.selectedThroughput) {
				prompt += `**Throughput:** ${this.selectedThroughput}\n`;
			}
			
			if (this.selectedSpecies) {
				prompt += `**Species Constraints:** ${this.selectedSpecies}\n`;
			}
			
			if (this.selectedTimeBudget) {
				prompt += `**Time Budget:** ${this.selectedTimeBudget}\n`;
			}
			
			if (this.experimentNotes.trim() !== '') {
				prompt += `**Additional Notes:** ${this.experimentNotes.trim()}\n`;
			}
			
			return prompt;
		},
		*/
		isValidExperimentJSON(str) {
			if (!str || typeof str !== 'string') return false;
			try {
				const parsed = JSON.parse(str);
				return parsed && parsed.resultModel && Array.isArray(parsed.resultModel) && parsed.resultModel.length > 0;
			} catch (error) {
				return false;
			}
		},
		// COMMENTED OUT: generateExperiment method
		/*
		async generateExperiment() {
			try {
				// Validate that we have the required inputs
				if (!this.phenotypeSearch.trim() && this.selectedGenes.length === 0) {
					alert('Please provide a hypothesis and/or select genes to generate experiment plans.');
					return;
				}
				
				// Show loading state and start timer
				this.isGenerating = true;
				this.generationStartTime = Date.now();
                
				// Choose the appropriate prompt based on gene strategy
				let prompt;
				if (this.selectedGenes.length > 0 && this.geneExperimentStrategy === 'all_together') {
					prompt = this.experimentPromptGenes();
				} else {
					prompt = this.experimentPrompt();
				}
				
				// Start timer to update elapsed time every second
				this.generationTimer = setInterval(() => {
					if (this.isGenerating && this.generationStartTime) {
						const elapsed = Math.floor((Date.now() - this.generationStartTime) / 1000);
						const minutes = Math.floor(elapsed / 60);
						const seconds = elapsed % 60;
						this.elapsedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
					}
				}, 1000);
				
				// Generate experiment using the LLM client
				this.buildExperiments.sendPrompt({
					userPrompt: prompt.trim() || 'Generate validation experiments based on the selected parameters',
					onResponse: (response) => {
						// Store the response for display
						this.experimentResults = response;
						// Collapse the search draft section when response is received
						// Experiment plan summary is now always visible
					},
					onError: (error) => {
						console.error('Error generating experiment:', error);
						this.experimentResults = 'Error generating experiment. Please try again.';
						// Also collapse on error to show the error message
						// Experiment plan summary is now always visible
					},
					onEnd: () => {
						this.isGenerating = false;
						this.clearGenerationTimer();
						// Call completion callback if provided
						if (onComplete) {
							onComplete();
						}
					}
				});
				
			} catch (error) {
				console.error('Error generating experiment:', error);
				this.experimentResults = 'Error generating experiment. Please try again.';
				this.isGenerating = false;
				this.clearGenerationTimer();
				// Collapse on synchronous error as well
				this.showSearchDraft = false;
			}
		},
		*/
		clearGenerationTimer() {
			if (this.generationTimer) {
				clearInterval(this.generationTimer);
				this.generationTimer = null;
			}
			this.generationStartTime = null;
			this.elapsedTime = '0:00';
		},
		// Generate scores for genes on current page that don't have scores yet
		async generateScoresForCurrentPage() {
			// Only proceed if we have a hypothesis and genes
			if (!this.phenotypeSearch.trim() || this.geneData.length === 0) {
				return;
			}

			// Get genes on current page that don't have novelty scores yet
			const currentPageGenes = this.paginatedGeneData;
			const genesNeedingScores = currentPageGenes.filter(gene =>
				!this.geneNovelty[gene.gene] && gene.gene && gene.isManual
			);

			if (genesNeedingScores.length === 0) {
				return; // All genes on this page already have scores
			}

			// Limit to 10 genes as per prompt constraints
			const genesToProcess = genesNeedingScores.slice(0, 10).map(g => g.gene);

			if (genesToProcess.length === 0) {
				return;
			}

			console.log(`Generating scores for ${genesToProcess.length} genes on page ${this.currentPage}:`, genesToProcess);

			try {
				await this.getNoveltyForManualGenes(genesToProcess);
			} catch (error) {
				console.error('Error generating scores for current page:', error);
			}
		},
		clearGeneScoringTimer() {
			if (this.geneScoringTimer) {
				clearInterval(this.geneScoringTimer);
				this.geneScoringTimer = null;
			}
			this.scoringInProgress = false;
			this.geneScoringStartTime = null;
			this.geneScoringElapsedTime = '0:00';
			this.genesBeingProcessed = [];
		},
		// Check if all genes currently being processed have been scored
		checkAllGenesScored() {
			if (this.genesBeingProcessed.length === 0) {
				return false;
			}
			
			return this.genesBeingProcessed.every(geneSymbol => {
				return this.geneNovelty[geneSymbol] && this.geneRelevance[geneSymbol];
			});
		},
		// Gene exploration methods
		getGeneCount() {
			if (!this.manualGenes.trim()) return 0;
			return this.manualGenes.split(',').map(gene => gene.trim()).filter(gene => gene).length;
		},
		async generateHypothesisAlignment() {
			// Check if hypothesis is provided
			if (!this.phenotypeSearch.trim()) {
				alert('Please provide a hypothesis in the "Hypothesis to Validate" section before generating scores.');
				return;
			}

			// Check if genes are provided
			if (!this.manualGenes.trim()) {
				alert('Please enter gene symbols in the gene input field.');
				return;
			}

			// Parse the manual genes input
			const geneList = this.manualGenes.split(',').map(gene => gene.trim()).filter(gene => gene);

			if (geneList.length === 0) {
				alert('Please enter valid gene symbols separated by commas.');
				return;
			}

			// Get existing genes in the table
			const existingGenes = this.geneData.map(gene => gene.gene);
			
			// Find new genes that aren't already in the table
			const newGenes = geneList.filter(gene => !existingGenes.includes(gene));
			
			if (newGenes.length === 0) {
				alert('All genes in your input are already in the table. No new genes to process.');
				return;
			}

			// If there are existing genes, show info about what we're doing
			if (existingGenes.length > 0) {
				alert(`Found ${newGenes.length} new genes to process (${geneList.length - newGenes.length} genes already in table). Processing new genes...`);
			}

			// Process only new genes, but generate scores for first 10 initially
			const genesToProcess = newGenes;
			if (newGenes.length > 10) {
				alert(`Processing ${newGenes.length} new genes. Scores for the first 10 genes will be generated initially, and scores for remaining genes will be generated as you navigate through pages.`);
			}

		// Set loading state and start timer
		this.isGeneratingScores = true;
		this.scoringInProgress = true;
		this.geneScoringStartTime = Date.now();
		this.geneScoringElapsedTime = '0:00';
		// Set the genes being processed (first 10)
		this.genesBeingProcessed = genesToProcess.slice(0, 10);

		// Start timer to update elapsed time every second
		this.geneScoringTimer = setInterval(() => {
			if (this.scoringInProgress && this.geneScoringStartTime) {
				const elapsed = Math.floor((Date.now() - this.geneScoringStartTime) / 1000);
				const minutes = Math.floor(elapsed / 60);
				const seconds = elapsed % 60;
				this.geneScoringElapsedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;

				// Check if all genes are scored every 5 seconds
				if (elapsed % 5 === 0 && this.checkAllGenesScored()) {
					this.scoringInProgress = false;
					this.isGeneratingScores = false;
					this.clearGeneScoringTimer();
				}
			}
		}, 1000);

			try {
				
				// Add genes to the table first (similar to addManualGenes but without clearing input)
				const genesToAdd = genesToProcess.map(gene => ({
							gene: gene,
					log_bf: null,
					prior: null,
					combined: null,
					directPPA: null,
					indirectPPA: null,
					source: 'Manual Input',
					phenotype: 'Manual Input',
							isManual: true
						}));
						
				// Add to existing gene data
				this.geneData = [...this.geneData, ...genesToAdd];
				this.originalGeneData = [...this.originalGeneData, ...genesToAdd];

				// Keep genes in input field for other explore options

				// Generate scores for first 10 genes initially
				const firstBatch = genesToProcess.slice(0, 10);
				await this.getNoveltyForManualGenes(firstBatch);


			} catch (error) {
				console.error('Error generating hypothesis alignment:', error);
				alert('Error generating hypothesis alignment. Please try again.');
				// Reset loading state and clear timer on error
				this.scoringInProgress = false;
				this.isGeneratingScores = false;
				this.clearGeneScoringTimer();
			}
		},
		exploreGTExExpression() {
			// Parse genes from manual input
			const geneList = this.manualGenes
				.split(',')
				.map(gene => gene.trim())
				.filter(gene => gene);

			if (geneList.length === 0) {
				alert('Please enter gene symbols in the gene input field.');
				return;
			}

			// Check gene limit
			if (geneList.length > 50) {
				alert('GTEx browser supports a maximum of 50 genes. Please reduce your gene list.');
				return;
			}

			// Create GTEx browser URL with genes
			const genesParam = geneList.join(',');
			const gtexUrl = `https://www.gtexportal.org/home/multiGeneQueryPage/${genesParam}`;
			
			// Open in new tab
			window.open(gtexUrl, '_blank');
		},
		async enrichGenes() {
			// Parse genes from manual input
			const geneList = this.manualGenes
				.split(',')
				.map(gene => gene.trim())
				.filter(gene => gene);

			if (geneList.length === 0) {
				alert('Please enter gene symbols in the gene input field.');
				return;
			}

			try {
				// Create description for the gene set
				const description = `Gene set from CFDE Genes Validator: ${geneList.join(', ')}`;
				
				// Create Playbook Workflow Builder URL
				const workflowUrl = await drcUtils.create_pwb_gene_set_workflow(geneList, description);
				
				// Open in new tab
				window.open(workflowUrl, '_blank');
			} catch (error) {
				console.error('Error creating Playbook workflow:', error);
				alert('Error opening Playbook Workflow Builder. Please try again.');
			}
		}
	}
};
</script>

<style scoped>
/* Main Background - CFDE Knowledge Center Style */
body {
    background-color: #F8F8F8;
}

a {
    color: #FF6600 !important;
}

/* Gene Input Section (Primary) */
.gene-input-section {
    margin-top: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.gene-input-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 5px;
}

.gene-input-header label {
    font-weight: 600;
    color: #333;
    margin: 0;
}

.switch-to-associations-link {
    color: #FF6600;
    text-decoration: none;
    font-size: 0.9em;
    font-weight: normal;
}

.switch-to-associations-link:hover {
    text-decoration: underline;
}

.format-suggestion {
    color: #666;
    font-size: 0.85em;
    margin-bottom: 8px;
    display: block;
}

.manual-genes-field {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    font-family: inherit;
    resize: vertical;
    min-height: 60px;
}

.manual-genes-field:focus {
    outline: none;
    border-color: #FF6600;
    box-shadow: 0 0 0 2px rgba(255, 102, 0, 0.2);
}

.gene-sets-field {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    font-family: inherit;
    resize: vertical;
    min-height: 80px;
}

.gene-sets-field:focus {
    outline: none;
    border-color: #FF6600;
    box-shadow: 0 0 0 2px rgba(255, 102, 0, 0.2);
}

.load-genes-section {
    margin-top: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.load-genes-btn {
    align-self: flex-start;
    display: flex;
    align-items: center;
    gap: 8px;
}

.load-genes-hint {
    color: #666;
    font-size: 0.85em;
    margin: 0;
}

.manual-add-link {
    color: #FF6600;
    text-decoration: none;
    font-size: 0.9em;
    font-weight: normal;
}

.manual-add-link:hover {
    text-decoration: underline;
}

/* Gene Options Section */
.gene-options-section {
    margin: 30px 0;
    padding: 20px;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
}

.gene-options-header {
    margin-bottom: 20px;
}

.gene-options-header h4 {
    color: #333;
    margin: 0 0 8px 0;
    font-size: 1.2em;
}

.gene-options-description {
    color: #666;
    margin: 0;
    font-size: 0.95em;
    line-height: 1.4;
}

.gene-options-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.gene-option-card {
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: box-shadow 0.2s ease;
}

.gene-option-card:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.option-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 12px;
}

.option-header h5 {
    margin: 0;
    color: #333;
    font-size: 1.1em;
    line-height: 1.3;
}

.option-badge {
    background: #e3f2fd;
    color: #1976d2;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.75em;
    font-weight: 600;
    margin-left: 10px;
    white-space: nowrap;
}

.option-description {
    margin-bottom: 15px;
}

.option-description p {
    margin: 0;
    color: #666;
    font-size: 0.9em;
    line-height: 1.4;
}

.option-details {
    margin-bottom: 15px;
}

.option-details ul {
    margin: 0;
    padding-left: 20px;
    color: #555;
    font-size: 0.85em;
    line-height: 1.4;
}

.option-details li {
    margin-bottom: 4px;
}

.option-actions {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.option-btn {
    align-self: flex-start;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    font-size: 0.9em;
}

.option-note {
    color: #666;
    font-size: 0.8em;
    font-style: italic;
}

/* Gene Data Table Section */
.gene-data-table-section {
    margin-top: 30px;
}

.gene-scoring-banner {
    background: #e3f2fd;
    border: 1px solid #bbdefb;
    padding: 12px 16px;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.banner-content {
    display: flex;
    align-items: center;
    gap: 10px;
}

.banner-text {
    color: #1976d2;
    font-weight: 500;
}

.gene-data-header {
    margin-bottom: 15px;
}

.gene-data-label {
    font-weight: 600;
    color: #333;
    margin: 0 0 8px 0;
    font-size: 1.1em;
}

.gene-data-description {
    color: #666;
    margin: 0;
    font-size: 0.9em;
    line-height: 1.4;
}

.table-container {
    overflow-x: auto;
    margin-bottom: 20px;
}

.gene-data-table {
    width: 100%;
    border-collapse: collapse;
    background: white;
    border: 1px solid #ddd;
}

.gene-data-table th {
    background: #f8f9fa;
    color: #333;
    font-weight: 600;
    padding: 12px 8px;
    text-align: left;
    border-bottom: 2px solid #dee2e6;
    font-size: 0.9em;
}

.gene-data-table td {
    padding: 10px 8px;
    border-bottom: 1px solid #dee2e6;
    vertical-align: top;
    font-size: 0.9em;
}

.gene-data-table tr:hover {
    background: #f8f9fa;
}

.gene-checkbox {
    margin: 0;
}

.relevance-cell, .novelty-cell {
    text-align: center;
    min-width: 80px;
}

.score-content {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 4px;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
}

.score-content.high-score {
    background: #d4edda;
    border-color: #c3e6cb;
    color: #155724;
}

.score-value {
    font-weight: 600;
    font-size: 0.9em;
}

.reason-cell {
    max-width: 300px;
    word-wrap: break-word;
}

.reason-content {
    font-size: 0.85em;
    line-height: 1.3;
    color: #555;
}

.loading-text {
    color: #666;
    font-style: italic;
    font-size: 0.85em;
}

.view-button {
    background: #007bff;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
    cursor: pointer;
    transition: background 0.2s;
}

.view-button:hover {
    background: #0056b3;
}

.view-button.active {
    background: #6c757d;
}

.evidence-subtable {
    margin: 10px 0;
    padding: 15px;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
}

.evidence-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85em;
}

.evidence-table th {
    background: #e9ecef;
    color: #333;
    font-weight: 600;
    padding: 8px 6px;
    text-align: left;
    border-bottom: 1px solid #dee2e6;
}

.evidence-table td {
    padding: 6px;
    border-bottom: 1px solid #dee2e6;
}

.evidence-table tr:hover {
    background: #f1f3f4;
}

/* Pagination */
.pagination-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 20px;
    padding: 15px 0;
}

.pagination-info {
    color: #666;
    font-size: 0.9em;
}

.pagination-controls {
    display: flex;
    align-items: center;
    gap: 5px;
}

.pagination-btn {
    background: white;
    border: 1px solid #ddd;
    color: #333;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85em;
    transition: all 0.2s;
}

.pagination-btn:hover:not(:disabled) {
    background: #f8f9fa;
    border-color: #FF6600;
}

.pagination-btn:disabled {
    background: #f8f9fa;
    color: #999;
    cursor: not-allowed;
    border-color: #e9ecef;
}

.first-last-btn {
    font-weight: bold;
}

.page-numbers {
    display: flex;
    gap: 2px;
}

.page-btn {
    background: white;
    border: 1px solid #ddd;
    color: #333;
    padding: 6px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85em;
    min-width: 32px;
    text-align: center;
    transition: all 0.2s;
}

.page-btn:hover {
    background: #f8f9fa;
    border-color: #FF6600;
}

.page-btn.active {
    background: #FF6600;
    color: white;
    border-color: #FF6600;
}

/* Loading Spinner */
.loading-spinner-small {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid #FF6600;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Responsive Design */
@media (max-width: 768px) {
    .gene-options-grid {
        grid-template-columns: 1fr;
    }
    
    .gene-option-card {
        padding: 15px;
    }
    
    .option-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
    }
    
    .option-badge {
        margin-left: 0;
        align-self: flex-start;
    }
}
</style>
					if (experiment.feasibility_details) {
						content += `FEASIBILITY DETAILS:\n`;
						if (experiment.feasibility_details.required_capabilities) {
							content += `Required Capabilities:\n`;
							experiment.feasibility_details.required_capabilities.forEach(cap => {
								content += `- ${cap}\n`;
							});
						}
						content += `Expected Timeline: ${experiment.feasibility_details.expected_timeline}\n`;
						content += `Estimated Conditions: ${experiment.feasibility_details.Estimated_conditions}\n`;
						if (experiment.feasibility_details.required_materials) {
							content += `Required Materials:\n`;
							experiment.feasibility_details.required_materials.forEach(mat => {
								content += `- ${mat}\n`;
							});
						}
						content += '\n';
					}
					
					// Design Critique
					if (experiment.design_critique) {
						content += `DESIGN CRITIQUE:\n`;
						if (experiment.design_critique.strengths) {
							content += `Strengths:\n`;
							experiment.design_critique.strengths.forEach(strength => {
								content += `- ${strength}\n`;
							});
						}
						if (experiment.design_critique.limitations) {
							content += `Limitations:\n`;
							experiment.design_critique.limitations.forEach(limitation => {
								content += `- ${limitation}\n`;
							});
						}
						if (experiment.design_critique.justification_for_deviation) {
							content += `Justification for Deviation: ${experiment.design_critique.justification_for_deviation}\n`;
						}
						if (experiment.design_critique.alternative_approaches) {
							content += `Alternative Approaches:\n`;
							experiment.design_critique.alternative_approaches.forEach(alt => {
								content += `- ${alt.type}: ${alt.suggestion}\n`;
							});
						}
						content += `Strategic Recommendation: ${experiment.design_critique.strategic_recommendation}\n\n`;
					}
					
					// Provenance
					if (experiment.provenance) {
						content += `PROVENANCE:\n`;
						content += `${experiment.provenance}\n\n`;
					}
					
					content += '---\n\n';
				});
			} else {
				// Fallback to raw results if not valid JSON
				content += 'EXPERIMENT RESULTS:\n';
				content += '-------------------\n';
				content += this.experimentResults;
			}
			
			// Add disclaimers at the end
			content += '\n\n';
			content += 'IMPORTANT DISCLAIMERS\n';
			content += '====================\n\n';
			
			// Main experiment disclaimer
			content += 'âš ï¸ IMPORTANT DISCLAIMER\n';
			content += 'This tool is designed to help generate testable experiment plans for hypothesis validation, not to provide definitive scientific guidance.\n\n';
			content += 'Please note that:\n';
			content += 'â€¢ These experiment plans are AI-generated suggestions and should be reviewed by qualified researchers\n';
			content += 'â€¢ Plans may not align with current journal standards, field-specific requirements, or institutional protocols\n';
			content += 'â€¢ Always consult with domain experts and follow established laboratory safety and ethical guidelines\n';
			content += 'â€¢ Verify all technical details, protocols, and safety considerations before implementation\n';
			content += 'â€¢ Consider your specific experimental context, resources, and constraints\n\n';
			content += 'Use these suggestions as a starting point for discussion and planning, not as final experimental protocols.\n\n';
			
			// Timeline disclaimer
			content += 'TIMELINE DISCLAIMER\n';
			content += 'Please note these timelines are general estimates, not absolute predictions, and that timelines assume the user already has the animals/cells/experimental reagents in-hand and the appropriate animal and/or institutional protocols in place to conduct these experiments. All researchers should be responsible for conducting their experiments in accordance with ethical guidelines as required by their institution.\n\n';
			
			// Conditions disclaimer
			content += 'CONDITIONS DISCLAIMER\n';
			content += 'Please note: These are general estimates. Researchers should perform a power calculation for each assay to determine the appropriate number of mice required for the experiment based on expected effect size, variability, and desired statistical power.\n\n';
			
			// Citation information
			content += 'CITATION INFORMATION\n';
			content += 'If you use this tool in a scientific publication, presentation, or other output, please cite the CFDE Knowledge Center in the following format:\n\n';
			content += 'The Common Fund Data Ecosystem Knowledge Center (https://www.cfdeknowledge.org), supported by NIH Office of the Director, Fund OT2OD036440. Year Month Date of access; URL of page cited. Specific identifiers/ accession numbers for datasets used.\n\n';
			content += 'Additional Citation Requirements:\n';
			content += 'â€¢ Users citing data and/or resources collected through other CFDE- or non-CFDE-generated studies should also cite all underlying studies comprising those datasets\n';
			content += 'â€¢ All published datasets must be cited according to the associated publication, using DOIs and PMIDs when available\n';
			content += 'â€¢ Data reused from third-party repositories must adhere to their citation policies\n\n';
			content += 'Citation policies for each page or analysis on the Knowledge Center are available here: https://cfdeknowledge.org/r/cfdekc_policies_citation\n';
			
			return content;
		}
		*/
	}
};
/*


*/
</script>
<style scoped>
/* Main Background - CFDE Knowledge Center Style */
body {
    background-color: #F8F8F8;
}

a {
    color: #FF6600 !important;
}

/* Two Column Layout */
.upper-layout {
    margin-bottom: 20px;
}

/* Configuration Section Styles */
.configuration-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    margin-bottom: 15px;
    cursor: pointer;
}

.configuration-header:hover {
    background: #e9ecef;
}

.configuration-header h4 {
    color: #FF6600;
    font-size: 18px;
    font-weight: 700;
    margin: 0 0 15px 0;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.configuration-toggle {
    font-size: 20px;
    font-weight: bold;
    color: #6c757d;
    width: 30px;
    height: 30px;
    align-items: center;
    justify-content: center;
}

/* Responsive Design */
@media (max-width: 1200px) {
    .upper-layout {
        flex-direction: column;
    }
    
    .left-column,
    .right-column {
        flex: 1;
        max-width: 100%;
    }
}

/* Section Wrappers - CFDE Card Style */
.hypothesis-container, .section-wrapper {
    background: #ffffff;
    padding: 20px;
    margin-bottom: 20px;
    /*border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    border: 1px solid #e9ecef;*/
}

/* Section Headers - CFDE Orange Style */
.section-header h4 {
    color: #FF6600;
    font-size: 18px;
    font-weight: 700;
    margin: 0 0 15px 0;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.hypothesis-content h5 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #333333;
    font-size: 14px;
    font-weight: 600;
}

.hypothesis-section {
    background: #ffffff;
    padding: 20px;
    /*border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);*/
}

.parameters-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}

.experimental-constraints {
    /*background: #ffffff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    */
    margin-top: 20px;
}

.experimental-constraints h4, .experimental-parameters h4, .additional-notes h4 {
    margin-top: 0;
    margin-bottom: 20px;
    color: #FF6600;
    font-size: 16px;
    font-weight: 600;
}

.additional-notes {
    /*background: #ffffff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);*/
    margin-top: 20px;
}

.notes-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 0 5px;
}

.notes-section label {
    font-weight: 500;
    color: #495057;
    font-size: 14px;
}

.notes-textarea {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 14px;
    font-family: inherit;
    resize: vertical;
    min-height: 80px;
    background-color: white;
}

.notes-textarea:focus {
    outline: none;
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.notes-textarea:hover {
    border-color: #86b7fe;
}


.gene-sets-input {
    margin-top: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.gene-sets-input label {
    font-weight: 500;
    color: #333333;
    font-size: 14px;
}

.format-suggestion {
    display: block;
    color: #777777;
    font-size: 12px;
    font-style: italic;
    margin: 4px 0 8px 0;
    padding: 4px 8px;
    background-color: #F8F8F8;
    border-left: 3px solid #7c757d;
}

.gene-sets-field {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #CCCCCC;
    border-radius: 6px;
    font-size: 14px;
    font-family: inherit;
    resize: vertical;
    min-height: 60px;
    background-color: white;
}

.gene-sets-field:focus {
    outline: none;
    border-color: #007BFF;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.gene-sets-field:hover {
    border-color: #007BFF;
}


.constraints-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
}

.constraint-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.constraint-section label {
    font-weight: 500;
    color: #333333;
    font-size: 14px;
}

.constraint-select {
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 14px;
    background-color: white;
    cursor: pointer;
}

.constraint-select:focus {
    outline: none;
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.constraint-select:hover {
    border-color: #86b7fe;
}

.filter-section, .constraint-section {
    background: #ffffff;
    padding: 7px;
}

.filter-section h5 {
    margin-top: 0;
    margin-bottom: 10px;
    color: #333333;
    font-size: 14px;
    font-weight: 600;
}

.form-control {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #CCCCCC;
    border-radius: 4px;
    font-size: 14px;
    background-color: white;
}

.readouts-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid #CCCCCC;
    border-radius: 4px;
    padding: 10px;
    background: white;
}

.readout-item {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
}

.readout-item input[type="checkbox"] {
    margin-right: 8px;
}

.readout-item label {
    margin: 0;
    font-size: 13px;
    cursor: pointer;
}

.search-summary {
    margin-top: 20px;
}

.summary-card {
    background: #e3f2fd;
    padding: 15px;
    border-radius: 8px;
}

.summary-card p {
    margin: 5px 0;
    font-size: 14px;
}

/* Configuration Summary Styles */
.config-summary {
    margin-bottom: 20px;
}

.config-summary h6 {
    color: #333333;
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 15px 0;
    padding-bottom: 8px;
}

.config-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 12px;
}

.config-item {
    background: white;
    padding: 12px;
    border-left: 3px solid #55AAEE;
    font-size: 14px;
    line-height: 1.4;
}

.config-item strong {
    color: #333333;
    font-weight: 600;
}

.gene-list {
    color: #666666;
    font-size: 13px;
    font-style: italic;
}

/* Experiment Plan Context Styles */
.search-context h6 {
    color: #333333;
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 15px 0;
    padding-bottom: 8px;
}

.experiment-plan-info p {
    margin: 0;
    color: #333333;
    font-size: 14px;
}

/* Loading text in table cells */
.novelty-cell .loading-text,
.relevance-cell .loading-text,
.reason-cell .loading-text {
    color: #999999;
    font-size: 12px;
    font-style: italic;
}

.search-context {
    margin: 15px 0;
    padding: 12px;
    background-color: #ffffff;
    border-radius: 4px;
}

.search-context h6 {
    margin: 0 0 8px 0;
    /*color: #495057;*/
    font-size: 14px;
    font-weight: 600;
}

.search-context p {
    margin: 0 0 10px 0;
    font-size: 13px;
    color: #6c757d;
    line-height: 1.4;
}

.search-context ol {
    margin: 10px 0;
    padding-left: 20px;
}

.search-context li {
    margin: 8px 0;
    font-size: 13px;
    line-height: 1.4;
}

.search-context strong {
    font-weight: 600;
}


.association-groups-selection p {
    margin: 0 0 15px 0;
    font-size: 13px;
}

.groups-checkbox-container {
    margin: 10px 0;
}

.group-checkbox-item {
    margin: 8px 0;
    display: flex;
    align-items: flex-start;
}

.group-checkbox {
    margin-right: 10px;
    margin-top: 2px;
}

.group-label {
    font-size: 13px;
    color: #856404;
    cursor: pointer;
    line-height: 1.4;
}

.group-label strong {
    color: #495057;
    font-weight: 600;
}

.gene-sets-count {
    color: #6c757d;
    font-weight: normal;
}

.selection-warning {
    margin: 10px 0;
    color: #dc3545;
    font-style: italic;
}

.selection-summary {
    margin: 10px 0;
    color: #28a745;
    font-weight: 500;
}


.ignore-checkbox-item {
    display: flex;
    align-items: flex-start;
}

.ignore-checkbox {
    margin-right: 12px;
    margin-top: 2px;
}

.ignore-label {
    font-size: 13px;
    color: #495057;
    cursor: pointer;
    line-height: 1.4;
}

.ignore-label strong {
    color: #dc3545;
    font-weight: 600;
    display: block;
    margin-bottom: 4px;
}

.ignore-description {
    color: #6c757d;
    font-weight: normal;
    font-size: 12px;
    display: block;
}

.selection-status {
    margin: 10px 0;
}

.ignore-mode-summary {
    margin: 10px 0;
    color: #dc3545;
    font-weight: 500;
    padding: 8px 12px;
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    border-radius: 4px;
}


.btn {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    margin-top: 10px;
}

.btn-primary {
    background-color: #55AAEE;
    color: white;
}

.btn-primary:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
}

.btn-primary:hover:not(:disabled) {
    background-color: #0056b3;
}

.btn-secondary {
    background-color: #6c757d;
    color: white;
}

.btn-secondary:hover {
    background-color: #545b62;
}

.btn-success {
    background-color: #28a745;
    color: white;
}

.btn-success:hover {
    background-color: #218838;
}

.experiment-actions {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 15px;
    flex-wrap: wrap;
}

.action-buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 20px;
    /*padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #e9ecef;*/
}

/* Dropdown styles */
.dropdown-container {
    position: relative;
    display: inline-block;
    width: 100%;
}

.dropdown-toggle {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    background: white;
    text-align: left;
    cursor: pointer;
    font-size: 14px;
}

.dropdown-toggle:hover {
    border-color: #86b7fe;
}

.dropdown-toggle::after {
    float: right;
    margin-right: 10px; /* Adjust as needed for spacing */
    margin-top: 10px; /* Adjust as needed for vertical alignment */
}

.filter-section h5 {
    color: #495057;
}

.required-asterisk {
    color: #dc3545;
}

.dropdown-content {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid #ced4da;
    border-top: none;
    border-radius: 0 0 4px 4px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.checkbox-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    border-bottom: 1px solid #f8f9fa;
}

.checkbox-item:last-child {
    border-bottom: none;
}

.checkbox-item:hover {
    background-color: #f8f9fa;
}

.checkbox-item input[type="checkbox"] {
    margin-right: 8px;
}

.checkbox-item label {
    margin: 0;
    font-size: 13px;
    cursor: pointer;
    flex: 1;
}

.category-section {
    border-bottom: 1px solid #e9ecef;
}

.category-section:last-child {
    border-bottom: none;
}

.category-header {
    background-color: #f8f9fa;
    padding: 8px 12px;
    font-weight: 600;
    font-size: 12px;
    color: #495057;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 1px solid #dee2e6;
}

.group-section {
    border-bottom: 1px solid #e9ecef;
}

.group-section:last-child {
    border-bottom: none;
}

.group-header {
    background-color: #e9ecef;
    padding: 6px 12px;
    font-weight: 500;
    font-size: 11px;
    color: #6c757d;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    border-bottom: 1px solid #dee2e6;
}

.subgroup-section {
    border-bottom: 1px solid #f8f9fa;
    margin-left: 8px;
}

.subgroup-section:last-child {
    border-bottom: none;
}

.subgroup-header {
    background-color: #f8f9fa;
    padding: 4px 12px;
    font-weight: 500;
    font-size: 10px;
    color: #868e96;
    text-transform: uppercase;
    letter-spacing: 0.2px;
    border-bottom: 1px solid #e9ecef;
    margin-left: -8px;
}



/* Results section styles */
#planner-search-results {
    margin-top: 20px;
    background: #ffffff;
    padding: 20px;
    /*border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);*/
}

.protocol-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
}

.protocol-header h4 {
    margin: 0;
    color: #ff6600;
    font-size: 21px;
    font-weight: 600;
}

.download-btn {
    padding: 8px 16px;
    font-size: 14px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    color: white;
    transition: background-color 0.2s ease;
}

.protocol-footer {
    display: flex;
    justify-content: flex-end;
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #e9ecef;
}

/* Removed .results-container - no longer needed */

.loading-message {
    text-align: center;
    padding: 20px;
    color: #6c757d;
    font-style: italic;
}


.experiment-results pre {
    margin: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.4;
    color: #495057;
}

/* Experiment Disclaimer Styles */
.experiment-disclaimer {
    background: #fff3cd;
    border-left: 4px solid #FF6600;
    margin-bottom: 25px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.disclaimer-header {
    margin-bottom: 15px;
}

.disclaimer-header h5 {
    margin: 0;
    color: #856404;
    font-size: 16px;
    font-weight: 600;
}

.disclaimer-content {
    color: #856404;
    font-size: 14px;
    line-height: 1.5;
}

.disclaimer-content p {
    margin: 0 0 12px 0;
}

.disclaimer-content p:last-child {
    margin-bottom: 0;
}

.disclaimer-content ul {
    margin: 10px 0;
    padding-left: 20px;
}

.disclaimer-content li {
    margin-bottom: 6px;
}

.disclaimer-content strong {
    font-weight: 600;
}

.disclaimer-content em {
    font-style: italic;
    font-weight: 500;
}

/* Timeline Disclaimer Styles */
.timeline-disclaimer {
    margin-top: 8px;
    padding: 8px 12px;
    background: #f8f9fa;
    border-left: 3px solid #6c757d;
    font-size: 13px;
    line-height: 1.4;
}

.timeline-disclaimer small {
    color: #6c757d;
    display: block;
}

.timeline-disclaimer em {
    font-style: italic;
    font-weight: 400;
}

/* Conditions Disclaimer Styles */
.conditions-disclaimer {
    margin-top: 8px;
    padding: 8px 12px;
    background: #f8f9fa;
    border-left: 3px solid #6c757d;
    font-size: 13px;
    line-height: 1.4;
}

.conditions-disclaimer small {
    color: #6c757d;
    display: block;
}

.conditions-disclaimer em {
    font-style: italic;
    font-weight: 400;
}

/* Gene Strategy Options Styles */
.gene-strategy-options {
    margin: 15px 0;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.strategy-option {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 12px;
    transition: all 0.2s ease;
}

.strategy-option:hover {
    background: #e9ecef;
    border-color: #dee2e6;
}

.strategy-radio {
    margin: 0;
    margin-top: 2px;
}

.strategy-label {
    flex: 1;
    cursor: pointer;
    margin: 0;
}

.strategy-label strong {
    display: block;
    color: #333;
    font-size: 14px;
    margin-bottom: 4px;
}

.strategy-label small {
    display: block;
    color: #6c757d;
    font-size: 12px;
    line-height: 1.3;
}

.strategy-description {
    margin-top: 15px;
    padding: 10px 12px;
    background: #f8f9fa;
    border-left: 3px solid #6c757d;
}

.strategy-description p {
    margin: 0;
    font-size: 13px;
    line-height: 1.4;
}

.strategy-description em {
    font-style: italic;
    color: #495057;
}

/* Protocol Actions Styles */
.protocol-actions {
    display: flex;
    gap: 10px;
    align-items: center;
}

.citation-btn {
    margin-left: 0;
}

/* Citation Popup Styles */
.citation-popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.citation-popup {
    background: white;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.citation-popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 1px solid #e9ecef;
    background: #f8f9fa;
}

.citation-popup-header h4 {
    margin: 0;
    color: #333;
    font-size: 18px;
}

.citation-close-btn {
    background: none;
    border: none;
    font-size: 24px;
    color: #6c757d;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.citation-close-btn:hover {
    color: #333;
}

.citation-popup-content {
    padding: 20px;
    line-height: 1.6;
}

.citation-popup-content p {
    margin-bottom: 15px;
}

.citation-popup-content ul {
    margin: 15px 0;
    padding-left: 20px;
}

.citation-popup-content li {
    margin-bottom: 8px;
}

.citation-format {
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    padding: 15px;
    margin: 15px 0;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.5;
}

.citation-format p {
    margin: 0;
}

.citation-popup-content a {
    color: #FF6600;
    text-decoration: none;
}

.citation-popup-content a:hover {
    text-decoration: underline;
}

.citation-popup-footer {
    padding: 15px 20px;
    border-top: 1px solid #e9ecef;
    background: #f8f9fa;
    text-align: center;
}

/* Experiment Plan Layout Styles */
.experiment-plan {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.experiment-card {
    background: #ffffff;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.experiment-section {
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid #f8f9fa;
}

.experiment-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.section-title {
    color: #495057;
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 10px 0;
    padding-bottom: 5px;
    border-bottom: 2px solid #cccccc;
}

.program-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}

.program-name {
    font-weight: 600;
    color: #007bff;
    font-size: 14px;
}

.strength-badge {
    background: #e3f2fd;
    color: #1976d2;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
}

.assertion-content {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.hypothesis, .mechanism, .phenotype {
    line-height: 1.5;
    color: #495057;
}

.gene {
    margin-top: 8px;
}


.experiment-description {
    line-height: 1.6;
    color: #495057;
    font-style: italic;
    background: #f8f9fa;
    padding: 12px;
    border-left: 4px solid #FF6600;
}

.validation-reasons {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.reason-item {
    line-height: 1.5;
    color: #495057;
}

.protocol-details {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.protocol-item {
    line-height: 1.5;
    color: #495057;
}

.feasibility-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.feasibility-item {
    line-height: 1.5;
    color: #495057;
}

.setup-list, .materials-list {
    margin: 8px 0 0 0;
    padding-left: 20px;
}

.setup-list li, .materials-list li {
    margin: 4px 0;
    color: #6c757d;
}

.critique-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.critique-section {
    line-height: 1.5;
    color: #495057;
}

.critique-list {
    margin: 8px 0 0 0;
    padding-left: 20px;
}

.critique-list li {
    margin: 6px 0;
    line-height: 1.4;
}

.critique-list.strengths li {
    color: #28a745;
}

.critique-list.limitations li {
    color: #dc3545;
}

.alternatives {
    margin-top: 8px;
}

.alternative-item {
    margin: 8px 0;
    padding: 8px 12px;
    background: #f8f9fa;
    border-left: 3px solid #ffc107;
}

.alt-type {
    font-weight: 600;
    color: #495057;
}

.strategic-rec {
    margin-top: 8px;
    padding: 12px;
    background: #e3f2fd;
    border-left: 4px solid #2196f3;
    font-style: italic;
    line-height: 1.5;
}

.provenance-text {
    line-height: 1.5;
    color: #6c757d;
    font-size: 13px;
    font-style: italic;
}


.justification-text {
    margin-top: 8px;
    padding: 12px;
    background: #fff3cd;
    border-left: 4px solid #ffc107;
    line-height: 1.5;
    color: #495057;
    font-style: italic;
}


/* Collapsible Sections */
.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    user-select: none;
    padding: 10px 0;
    margin-bottom: 15px;
}


.collapse-icon {
    font-size: 14px;
    color: #6c757d;
    transition: transform 0.2s ease;
}

.collapsed .section-header {
   /* border-bottom: 1px solid #e9ecef;*/
    margin-bottom: 0;
}

.section-content {
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
    max-height: 2000px;
    opacity: 1;
}

.user-guidance, .experiment-plan-info {
    margin: 0 0 20px 0;
    padding: 12px 16px;
    background-color: #f8f9fa;
    border-left: 3px solid #FF6600;
}

.user-guidance p {
    margin: 0;
    font-size: 13px;
    line-height: 1.4;
    color: #495057;
}

.user-guidance strong {
    color: #495057;
    font-weight: 600;
}

.collapsed .section-content {
    max-height: 0;
    opacity: 0;
    padding: 0;
    margin: 0;
    transform: translateY(-10px);
}

#planner-search-ui, #planner-search-draft {
    background: #ffffff;
    padding: 20px;
    /*border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);*/
    margin-bottom: 20px;
}

#planner-search-draft {
    margin-top: 20px;
}

.section-header {
    transition: all 0.3s ease;
}

.collapsed .section-header {
    transform: scale(0.98);
}


/* Textarea styles */
.textarea-container {
    width: 100%;
}

.hypothesis-textarea {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 14px;
    font-family: inherit;
    resize: vertical;
    min-height: 60px;
    background-color: white;
}

.hypothesis-textarea:focus {
    outline: none;
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.selected-items {
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
}

.selected-item {
    display: flex;
    align-items: center;
    background: #e3f2fd;
    border: 1px solid #bbdefb;
    border-radius: 16px;
    padding: 4px 8px;
    font-size: 12px;
}

.selected-item span {
    margin-right: 5px;
}

.remove-btn {
    background: none;
    border: none;
    color: #666;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
    padding: 0;
    margin-left: 5px;
}

.remove-btn:hover {
    color: #333;
}

/* Gene Data Table Styles */
.gene-data-table-section {
    margin-top: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.gene-data-label {
    font-weight: 500;
    color: #333333;
    font-size: 14px;
}

.gene-data-description {
    display: block;
    color: #777777;
    font-size: 12px;
    font-style: italic;
    margin: 4px 0 8px 0;
    padding: 4px 8px;
    background-color: #F8F8F8;
    border-left: 3px solid #7c757d;
}





.table-container {
    overflow-x: auto;
    border-radius: 6px;
    background: white;
}

.gene-data-table {
    width: 100%;
    border-collapse: collapse;
    background: white;
    border: 1px solid #CCCCCC;
    border-radius: 6px;
    overflow: hidden;
}

.gene-data-table th {
    /*background: #EFEFEF;*/
    padding: 12px 8px;
    text-align: left;
    font-weight: 600;
    font-size: 13px;
    color: #333333;
    border-bottom: 1px solid #CCCCCC;
    white-space: nowrap;
}

.gene-data-table td {
    padding: 10px 8px;
    border-bottom: 1px solid #EEEEEE;
    font-size: 13px;
    color: #333333;
    vertical-align: top;
}

.gene-data-table tr:hover {
    background-color: #EFEFEF;
}

.gene-data-table tr:last-child td {
    border-bottom: none;
}


/* Checkbox Styles */
.select-all-checkbox, .gene-checkbox {
    width: 16px;
    height: 16px;
    cursor: pointer;
    accent-color: #007bff;
}

.select-all-checkbox {
    margin: 0;
}

.gene-checkbox {
    margin: 0;
}

.gene-data-table th:first-child,
.gene-data-table td:first-child {
    width: 40px;
    text-align: center;
    padding: 8px 4px;
}

/* Selected Genes Actions */
.selected-genes-actions {
    margin-top: 20px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 6px;
}

.selected-count {
    margin-bottom: 10px;
    font-size: 14px;
    color: #495057;
}

.selected-genes-list {
    margin-bottom: 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
}

.selected-gene-tag {
    display: inline-flex;
    align-items: center;
    background: #007bff;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
}

.remove-gene-btn {
    background: none;
    border: none;
    color: white;
    margin-left: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    padding: 0;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}

.remove-gene-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

.gene-actions {
    display: flex;
    gap: 10px;
}

.btn-sm {
    padding: 4px 8px;
    font-size: 12px;
    border-radius: 4px;
}

/* Gene Selection Status Styles */
.gene-selection-status {
    margin-bottom: 15px;
}

.selected-genes-display {
    margin: 8px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
}

.selected-gene-badge {
    display: inline-block;
    background: #007bff;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
}

.experiment-plan-info {
    margin-top: 10px;
    font-size: 14px;
    color: #495057;
}

.no-genes-selected {
    margin-bottom: 15px;
    padding: 10px;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 4px;
    color: #6c757d;
}

.warning-box {
    background: #fff3cd !important;
    border: 1px solid #ffeaa7 !important;
    border-radius: 6px;
    padding: 15px;
    margin-bottom: 15px;
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

.warning-icon {
    font-size: 18px;
    flex-shrink: 0;
    margin-top: 2px;
}

.warning-content {
    flex: 1;
}

.warning-content p {
    margin: 0;
    color: #856404;
    font-weight: 500;
}

.button-warning {
    margin-top: 8px;
    text-align: center;
}

.button-warning small {
    color: #dc3545;
    font-weight: 500;
}

/* Load Genes Section */
.load-genes-section {
    margin-top: 10px;
    text-align: center;
}

.load-genes-btn {
    margin-bottom: 5px;
    min-width: 120px;
}

.load-genes-hint {
    display: block;
    color: #6c757d;
    font-style: italic;
    margin-top: 5px;
}

/* Gene Input Section (Primary) */
.gene-input-section {
    margin-top: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.gene-input-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.gene-input-header label {
    margin: 0;
    font-weight: 600;
    color: #333;
    font-size: 14px;
}

.manual-add-link {
    color: #007bff;
    text-decoration: none;
    font-weight: normal;
    font-size: 0.9em;
}

.manual-add-link:hover {
    text-decoration: underline;
    color: #0056b3;
}

.switch-to-associations-link {
    color: #FF6600;
    text-decoration: none;
    font-size: 14px;
    font-weight: 500;
}

.switch-to-associations-link:hover {
    color: #e55a00;
    text-decoration: underline;
}

.manual-genes-field {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 14px;
    margin-bottom: 10px;
    resize: vertical;
    min-height: 60px;
}

.manual-genes-field:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.manual-gene-actions {
    display: flex;
    gap: 10px;
    justify-content: flex-start;
}

.add-genes-btn {
    min-width: 100px;
}

.cancel-btn {
    min-width: 80px;
}

/* Pagination Styles */
.pagination-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 15px;
    padding: 10px 0;
}

.pagination-info {
    font-size: 13px;
    color: #6c757d;
}

.filtered-out-info {
    color: #dc3545;
    font-weight: 500;
    margin-left: 8px;
}

.overlap-filtered-info {
    color: #fd7e14;
    font-weight: 500;
}

.pagination-controls {
    display: flex;
    align-items: center;
    gap: 5px;
}

.pagination-btn {
    padding: 6px 12px;
    min-width: 32px;
    text-align: center;
    border: 1px solid #dee2e6;
    background: white;
    color: #495057;
    border-radius: 16px;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.2s ease;
}

.pagination-btn:hover:not(:disabled) {
    background: #f8f9fa;
    border-color: #adb5bd;
}

.pagination-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.first-last-btn {
    padding: 6px 8px;
    font-weight: bold;
    font-size: 12px;
}

.page-numbers {
    display: flex;
    gap: 2px;
}

.page-btn {
    padding: 6px 10px;
    border: 1px solid #dee2e6;
    background: white;
    color: #495057;
    border-radius: 17px;
    cursor: pointer;
    font-size: 13px;
    min-width: 33.5px;
    text-align: center;
    transition: all 0.2s ease;
}

.page-btn:hover {
    background: #f8f9fa;
    border-color: #adb5bd;
}

.page-btn.active {
    background: #55AAEE;
    color: white;
    border-color: #55AAEE;
}

.page-btn.active:hover {
    background: #55AAEE;
    border-color: #55AAEE;
}

/* Gene Summary Loading Spinner */
.summary-cell {
    display: flex;
    align-items: center;
    min-height: 20px;
}

.loading-spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid #007bff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 8px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Gene Data Header Loading Indicator */
.gene-data-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}

.summary-loading-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 8px;
    background: #e3f2fd;
    border: 1px solid #bbdefb;
    border-radius: 4px;
    font-size: 12px;
    color: #1976d2;
}

.loading-spinner-small {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid #1976d2;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 8px;
}

.loading-text {
    font-weight: 500;
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 6px;
    color: #6c757d;
    font-size: 12px;
    font-style: italic;
}

/* Novelty & Relevance Column Styles */
.novelty-cell,
.relevance-cell,
.reason-cell {
    display: flex;
    align-items: center;
    min-height: 20px;
}

.score-content {
    display: flex;
    flex-direction: column;
    gap: 2px;
    font-size: 11px;
    line-height: 1.2;
    width: 100%;
}

.score-value {
    font-weight: 700;
    font-size: 13px;
}

/* High Score Text Color */
.novelty-cell .score-content .score-value,
.relevance-cell .score-content .score-value {
    color: #777777;
}

.novelty-cell .score-content.high-score .score-value,
.relevance-cell .score-content.high-score .score-value {
    color: #007BFF;
    font-weight: 700;
}

.score-context {
    color: #6c757d;
    font-style: italic;
    font-size: 13px;
    line-height: 1.1;
}

.reason-content {
    color: #495057;
    font-size: 14px;
    line-height: 1.3;
    word-wrap: break-word;
}

/* Evidence View Styles */
.view-button {
    display: block;
    background-color: #55aaee !important;
    border: solid 1px #3388cc;
    font-size: 10px !important;
    color: #ffffff;
    padding: 1px 10px !important;
    border-radius: 0.2rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.view-button:hover {
    background: #3388cc;
    transform: translateY(-1px);
}

.view-button.active {
    background: #dc3545;
}

.view-button.active:hover {
    background: #c82333;
}

.evidence-row {
    background-color: #f8f9fa;
}

.evidence-subtable {
    padding: 10px;
    background: white;
    border-radius: 4px;
    margin: 5px 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.evidence-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
}

.evidence-table th {
    background: #e9ecef;
    padding: 6px 8px;
    text-align: left;
    font-weight: 600;
    color: #495057;
    border: 1px solid #dee2e6;
}

.evidence-table td {
    padding: 6px 8px;
    border: 1px solid #dee2e6;
    background: white;
}

.evidence-table tr:nth-child(even) td {
    background: #f8f9fa;
}

/* URL Choice Dialog Styles */
.url-choice-dialog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.url-choice-dialog {
    background: white;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    max-width: 800px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    animation: dialogSlideIn 0.3s ease-out;
}

@keyframes dialogSlideIn {
    from {
        opacity: 0;
        transform: translateY(-20px) scale(0.95);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.url-choice-header {
    padding: 24px 24px 16px;
    border-bottom: 1px solid #e9ecef;
}

.url-choice-header h3 {
    margin: 0 0 8px 0;
    color: #FF6600;
    font-size: 24px;
    font-weight: 600;
}

.url-choice-header p {
    margin: 0;
    color: #666;
    font-size: 16px;
    line-height: 1.5;
}

.url-choice-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    padding: 24px;
}

.url-choice-option {
    border: 1px solid #e9ecef;
    padding: 20px;
    transition: all 0.2s ease;
    cursor: pointer;
    position: relative;
}

.url-choice-option:hover {
    border-color: #007bff;
    box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15);
    transform: translateY(-2px);
}

.url-choice-title {
    margin-bottom: 16px;
}

.url-choice-title h4 {
    margin: 0 0 8px 0;
    color: #333;
    font-size: 18px;
    font-weight: 600;
}

.url-choice-title p {
    margin: 0;
    color: #666;
    font-size: 14px;
    line-height: 1.4;
}

.url-choice-preview {
    margin-bottom: 16px;
    padding: 12px;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
}

.url-choice-preview strong {
    display: block;
    margin-bottom: 8px;
    color: #333;
    font-size: 13px;
    font-weight: 600;
}

.url-choice-preview pre {
    margin: 0;
    font-size: 12px;
    color: #666;
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 100px;
    overflow-y: auto;
}

.genes-list {
    font-family: 'Courier New', monospace;
    font-size: 13px;
    color: #333;
    word-break: break-word;
}

.url-choice-btn {
    width: 100%;
    padding: 6px 10px;
    font-size: 13px;
    font-weight: 600;
    border-radius: 6px;
    transition: all 0.2s ease;
}

.url-choice-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
}

.url-choice-actions {
    padding: 16px 24px 24px;
    border-top: 1px solid #e9ecef;
    text-align: center;
}

.url-choice-actions .btn {
    padding: 10px 24px;
    font-size: 14px;
}

/* Gene Scoring Banner Styles */
.gene-scoring-banner {
	background: #e3f2fd;
	border: 1px solid #bbdefb;
	border-radius: 6px;
	padding: 12px 16px;
	margin-bottom: 20px;
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.banner-content {
	display: flex;
	align-items: center;
	gap: 12px;
}

.banner-text {
	color: #1976d2;
	font-size: 14px;
	font-weight: 500;
	line-height: 1.4;
}

/* Gene Options Section Styles */
.gene-options-section {
	margin-top: 20px;
	padding: 20px;
	background: #ffffff;
	border: 1px solid #e9ecef;
}

.gene-options-header {
	margin-bottom: 20px;
}

.gene-options-header h4 {
	color: #FF6600;
	font-size: 18px;
	font-weight: 700;
	margin: 0 0 8px 0;
	text-transform: uppercase;
	letter-spacing: 0.5px;
}

.gene-options-description {
	color: #6c757d;
	font-size: 14px;
	margin: 0;
	line-height: 1.4;
}

.gene-options-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
	gap: 20px;
	margin-top: 20px;
}

.gene-option-card {
	background: #ffffff;
	border: 1px solid #e9ecef;
	border-radius: 8px;
	padding: 20px;
	transition: all 0.3s ease;
	position: relative;
	overflow: hidden;
}

.gene-option-card:hover {
	border-color: #007bff;
	box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15);
	transform: translateY(-2px);
}

.option-header {
	display: flex;
	justify-content: space-between;
	align-items: flex-start;
	margin-bottom: 12px;
}

.option-header h5 {
	margin: 0;
	color: #333;
	font-size: 16px;
	font-weight: 600;
	line-height: 1.3;
	flex: 1;
}

.option-badge {
	background: #e3f2fd;
	color: #1976d2;
	padding: 4px 8px;
	border-radius: 12px;
	font-size: 11px;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 0.5px;
	margin-left: 10px;
	flex-shrink: 0;
}

.option-description {
	margin-bottom: 15px;
}

.option-description p {
	margin: 0;
	color: #495057;
	font-size: 14px;
	line-height: 1.5;
}

.option-details {
	margin-bottom: 20px;
}

.option-details ul {
	margin: 0;
	padding-left: 20px;
	list-style: none;
}

.option-details li {
	position: relative;
	margin-bottom: 6px;
	color: #6c757d;
	font-size: 13px;
	line-height: 1.4;
}

.option-details li:before {
	content: "âœ“";
	position: absolute;
	left: -20px;
	color: #28a745;
	font-weight: bold;
	font-size: 12px;
}

.option-actions {
	display: flex;
	flex-direction: column;
	gap: 8px;
}

.option-btn {
	width: 100%;
	padding: 10px 16px;
	font-size: 14px;
	font-weight: 600;
	border-radius: 6px;
	transition: all 0.2s ease;
}

.option-btn:disabled {
	opacity: 0.6;
	cursor: not-allowed;
	background-color: #6c757d;
}

.option-note {
	font-size: 12px;
	color: #6c757d;
	text-align: center;
	font-style: italic;
}

/* Responsive Design */
@media (max-width: 768px) {
    .url-choice-dialog {
        width: 95%;
        margin: 20px;
    }
    
    .url-choice-options {
        grid-template-columns: 1fr;
        gap: 16px;
        padding: 20px;
    }
    
    .url-choice-option {
        padding: 16px;
    }
    
    .url-choice-header {
        padding: 20px 20px 16px;
    }
    
    .url-choice-header h3 {
        font-size: 20px;
    }
    
    .url-choice-header p {
        font-size: 14px;
    }
    
    .gene-options-grid {
        grid-template-columns: 1fr;
        gap: 16px;
    }
    
    .gene-option-card {
        padding: 16px;
    }
    
    .option-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
    }
    
    .option-badge {
        margin-left: 0;
        align-self: flex-start;
    }
}


</style>